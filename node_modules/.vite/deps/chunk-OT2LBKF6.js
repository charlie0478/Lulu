import {
  convertColorHexToRgb,
  encodeBase64,
  objectHasKey,
  parseUrl,
  sortByKey,
  testColorIsHex
} from "./chunk-HQRXJUTC.js";

// node_modules/@cloudinary/url-gen/config/BaseConfig.js
function isObject(a) {
  if (typeof a !== "object" || a instanceof Array) {
    return false;
  } else {
    return true;
  }
}
var Config = class {
  filterOutNonSupportedKeys(userProvidedConfig, validKeys) {
    const obj = /* @__PURE__ */ Object.create({});
    if (isObject(userProvidedConfig)) {
      Object.keys(userProvidedConfig).forEach((key) => {
        if (validKeys.indexOf(key) >= 0) {
          obj[key] = userProvidedConfig[key];
        } else {
          console.warn("Warning - unsupported key provided to configuration: ", key);
        }
      });
      return obj;
    } else {
      return /* @__PURE__ */ Object.create({});
    }
  }
};
var BaseConfig_default = Config;

// node_modules/@cloudinary/url-gen/internal/internalConstants.js
var ALLOWED_URL_CONFIG = [
  "cname",
  "secureDistribution",
  "privateCdn",
  "signUrl",
  "longUrlSignature",
  "shorten",
  "useRootPath",
  "secure",
  "forceVersion",
  "analytics",
  "queryParams"
];

// node_modules/@cloudinary/url-gen/config/URLConfig.js
var URLConfig = class _URLConfig extends BaseConfig_default {
  /**
   * @param {IURLConfig} userURLConfig
   */
  constructor(userURLConfig) {
    super();
    const urlConfig = this.filterOutNonSupportedKeys(userURLConfig, ALLOWED_URL_CONFIG);
    Object.assign(this, {
      secure: true
    }, urlConfig);
  }
  extend(userURLConfig) {
    const urlConfig = this.filterOutNonSupportedKeys(userURLConfig, ALLOWED_URL_CONFIG);
    return new _URLConfig(Object.assign({}, this, urlConfig));
  }
  /**
   * @param {string} value Sets the cname
   */
  setCname(value) {
    this.cname = value;
    return this;
  }
  /**
   * @param {string} value Sets the secureDistribution
   */
  setSecureDistribution(value) {
    this.secureDistribution = value;
    return this;
  }
  /**
   * @param {boolean} value Sets whether to use a private CDN (Removes cloudName from URL)
   */
  setPrivateCdn(value) {
    this.privateCdn = value;
    return this;
  }
  /**
   * @param value Sets whether or not to sign the URL
   */
  setSignUrl(value) {
    this.signUrl = value;
    return this;
  }
  /**
   * @param value Sets whether or not to use a long signature
   */
  setLongUrlSignature(value) {
    this.longUrlSignature = value;
    return this;
  }
  /**
   * @param value Sets whether or not to shorten the URL
   */
  setShorten(value) {
    this.shorten = value;
    return this;
  }
  /**
   * @param value Sets whether or not to use a root path
   */
  setUseRootPath(value) {
    this.useRootPath = value;
    return this;
  }
  /**
   * @param value Sets whether or not to deliver the asset through https
   */
  setSecure(value) {
    this.secure = value;
    return this;
  }
  /**
   * @param value Sets whether to force a version in the URL
   */
  setForceVersion(value) {
    this.forceVersion = value;
    return this;
  }
  /**
   * @param params Sets additional params
   */
  setQueryParams(params) {
    this.queryParams = params;
    return this;
  }
};
var URLConfig_default = URLConfig;

// node_modules/@cloudinary/transformation-builder-sdk/internal/qualifier/QualifierValue.js
var QualifierValue = class {
  /**
   *
   * @param {QualifierValue | QualifierValue[] | any[] | string | number}qualifierValue
   */
  constructor(qualifierValue) {
    this.values = [];
    this.delimiter = ":";
    if (this.hasValue(qualifierValue)) {
      this.addValue(qualifierValue);
    }
  }
  /**
   * @description Joins the provided values with the provided delimiter
   */
  toString() {
    return this.values.join(this.delimiter);
  }
  /**
   * @description Checks if the provided argument has a value
   * @param {any} v
   * @private
   * @return {boolean}
   */
  hasValue(v) {
    return typeof v !== "undefined" && v !== null && v !== "";
  }
  /**
   * @desc Adds a value for the this qualifier instance
   * @param {any} value
   * @return {this}
   */
  addValue(value) {
    if (Array.isArray(value)) {
      this.values = this.values.concat(value);
    } else {
      this.values.push(value);
    }
    this.values = this.values.filter((v) => this.hasValue(v));
    return this;
  }
  /**
   * @description Sets the delimiter for this instance
   * @param delimiter
   */
  setDelimiter(delimiter) {
    this.delimiter = delimiter;
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/unsupportedError.js
var UnsupportedError = class extends Error {
  constructor(message = "Unsupported") {
    super(message);
  }
};
function createUnsupportedError(message) {
  return new UnsupportedError(message);
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/qualifierToJson.js
function qualifierToJson() {
  return this._qualifierModel || { error: createUnsupportedError(`unsupported qualifier ${this.constructor.name}`) };
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/QualifierModel.js
var QualifierModel = class {
  constructor() {
    this._qualifierModel = {};
  }
  toJson() {
    return qualifierToJson.apply(this);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/qualifier/Qualifier.js
var Qualifier = class extends QualifierModel {
  constructor(key, qualifierValue) {
    super();
    this.delimiter = "_";
    this.key = key;
    if (qualifierValue instanceof QualifierValue) {
      this.qualifierValue = qualifierValue;
    } else {
      this.qualifierValue = new QualifierValue();
      this.qualifierValue.addValue(qualifierValue);
    }
  }
  toString() {
    const { key, delimiter, qualifierValue } = this;
    return `${key}${delimiter}${qualifierValue.toString()}`;
  }
  addValue(value) {
    this.qualifierValue.addValue(value);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/flag/FlagQualifier.js
var FlagQualifier = class extends Qualifier {
  constructor(flagType, flagValue) {
    let qualifierValue;
    if (flagValue) {
      qualifierValue = new QualifierValue([flagType, `${flagValue}`]).setDelimiter(":");
    } else {
      qualifierValue = flagType;
    }
    super("fl", qualifierValue);
    this.flagValue = flagValue;
  }
  toString() {
    return super.toString().replace(/\./, "%2E");
  }
  getFlagValue() {
    return this.flagValue;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/dataStructureUtils.js
function mapToSortedArray(map, flags2) {
  const array = Array.from(map.entries());
  flags2.forEach((flag) => {
    array.push(["fl", flag]);
  });
  return array.sort().map((v) => v[1]);
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/actionToJson.js
function actionToJson() {
  var _a, _b, _c;
  const actionModelIsNotEmpty = this._actionModel && Object.keys(this._actionModel).length;
  const sourceTransformationError = (_c = (_b = (_a = this._actionModel) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b.transformation) === null || _c === void 0 ? void 0 : _c.error;
  if (sourceTransformationError && sourceTransformationError instanceof Error) {
    return { error: sourceTransformationError };
  }
  if (actionModelIsNotEmpty) {
    return this._actionModel;
  }
  return { error: createUnsupportedError(`unsupported action ${this.constructor.name}`) };
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/ActionModel.js
var ActionModel = class {
  constructor() {
    this._actionModel = {};
  }
  toJson() {
    return actionToJson.apply(this);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/Action.js
var Action = class extends ActionModel {
  constructor() {
    super(...arguments);
    this.qualifiers = /* @__PURE__ */ new Map();
    this.flags = [];
    this.delimiter = ",";
    this.actionTag = "";
  }
  prepareQualifiers() {
  }
  /**
   * @description Returns the custom name tag that was given to this action
   * @return {string}
   */
  getActionTag() {
    return this.actionTag;
  }
  /**
   * @description Sets the custom name tag for this action
   * @return {this}
   */
  setActionTag(tag) {
    this.actionTag = tag;
    return this;
  }
  /**
   * @description Calls toString() on all child qualifiers (implicitly by using .join()).
   * @return {string}
   */
  toString() {
    this.prepareQualifiers();
    return mapToSortedArray(this.qualifiers, this.flags).join(this.delimiter);
  }
  /**
   * @description Adds the parameter to the action.
   * @param {SDK.Qualifier} qualifier
   * @return {this}
   */
  addQualifier(qualifier) {
    if (typeof qualifier === "string") {
      const [key, value] = qualifier.toLowerCase().split("_");
      if (key === "fl") {
        this.flags.push(new FlagQualifier(value));
      } else {
        this.qualifiers.set(key, new Qualifier(key, value));
      }
    } else {
      this.qualifiers.set(qualifier.key, qualifier);
    }
    return this;
  }
  /**
   * @description Adds a flag to the current action.
   * @param {Qualifiers.Flag} flag
   * @return {this}
   */
  addFlag(flag) {
    if (typeof flag === "string") {
      this.flags.push(new FlagQualifier(flag));
    } else {
      if (flag instanceof FlagQualifier) {
        this.flags.push(flag);
      }
    }
    return this;
  }
  addValueToQualifier(qualifierKey, qualifierValue) {
    this.qualifiers.get(qualifierKey).addValue(qualifierValue);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/background/actions/BackgroundColor.js
var BackgroundColor = class extends Action {
  constructor(color2) {
    super();
    this.addQualifier(new Qualifier("b", new QualifierValue(color2).setDelimiter("_")));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/prepareColor.js
function prepareColor(color2) {
  if (color2) {
    return color2.match(/^#/) ? `rgb:${color2.substr(1)}` : color2;
  } else {
    return color2;
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/RawAction.js
var RawAction = class {
  constructor(raw) {
    this.raw = raw;
  }
  toString() {
    return this.raw;
  }
  toJson() {
    return { error: createUnsupportedError(`unsupported action ${this.constructor.name}`) };
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/IErrorObject.js
function isErrorObject(obj) {
  const errorObj = obj;
  return "error" in errorObj && !!errorObj.error;
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/flag.js
function lossy() {
  return new FlagQualifier("lossy");
}
function preserveTransparency() {
  return new FlagQualifier("preserve_transparency");
}
function progressive(mode2) {
  return new FlagQualifier("progressive", mode2);
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/format/FormatQualifier.js
var FormatQualifier = class extends QualifierValue {
  constructor(val) {
    super(val);
    this.val = val;
  }
  getValue() {
    return this.val;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/objectFlip.js
function objectFlip(obj) {
  const result = {};
  Object.keys(obj).forEach((key) => {
    result[obj[key]] = key;
  });
  return result;
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/internalConstants.js
var ACTION_TYPE_TO_CROP_MODE_MAP = {
  limitFit: "limit",
  limitFill: "lfill",
  minimumFit: "mfit",
  thumbnail: "thumb",
  limitPad: "lpad",
  minimumPad: "mpad"
};
var ACTION_TYPE_TO_DELIVERY_MODE_MAP = {
  colorSpace: "cs",
  dpr: "dpr",
  density: "dn",
  defaultImage: "d",
  format: "f",
  quality: "q"
};
var ACTION_TYPE_TO_EFFECT_MODE_MAP = {
  redEye: "redeye",
  advancedRedEye: "adv_redeye",
  oilPaint: "oil_paint",
  unsharpMask: "unsharp_mask",
  makeTransparent: "make_transparent"
};
var ACTION_TYPE_TO_QUALITY_MODE_MAP = {
  autoBest: "auto:best",
  autoEco: "auto:eco",
  autoGood: "auto:good",
  autoLow: "auto:low",
  jpegminiHigh: "jpegmini:1",
  jpegminiMedium: "jpegmini:2",
  jpegminiBest: "jpegmini:0"
};
var ACTION_TYPE_TO_STREAMING_PROFILE_MODE_MAP = {
  fullHd: "full_hd",
  fullHdWifi: "full_hd_wifi",
  fullHdLean: "full_hd_lean",
  hdLean: "hd_lean"
};
var CHROMA_VALUE_TO_CHROMA_MODEL_ENUM = {
  444: "CHROMA_444",
  420: "CHROMA_420"
};
var COLOR_SPACE_MODEL_MODE_TO_COLOR_SPACE_MODE_MAP = {
  "noCmyk": "no_cmyk",
  "keepCmyk": "keep_cmyk",
  "tinySrgb": "tinysrgb",
  "srgbTrueColor": "srgb:truecolor"
};
var CHROMA_MODEL_ENUM_TO_CHROMA_VALUE = objectFlip(CHROMA_VALUE_TO_CHROMA_MODEL_ENUM);
var COLOR_SPACE_MODE_TO_COLOR_SPACE_MODEL_MODE_MAP = objectFlip(COLOR_SPACE_MODEL_MODE_TO_COLOR_SPACE_MODE_MAP);
var CROP_MODE_TO_ACTION_TYPE_MAP = objectFlip(ACTION_TYPE_TO_CROP_MODE_MAP);
var DELIVERY_MODE_TO_ACTION_TYPE_MAP = objectFlip(ACTION_TYPE_TO_DELIVERY_MODE_MAP);
var EFFECT_MODE_TO_ACTION_TYPE_MAP = objectFlip(ACTION_TYPE_TO_EFFECT_MODE_MAP);
var QUALITY_MODE_TO_ACTION_TYPE_MAP = objectFlip(ACTION_TYPE_TO_QUALITY_MODE_MAP);
var STREAMING_PROFILE_TO_ACTION_TYPE_MAP = objectFlip(ACTION_TYPE_TO_STREAMING_PROFILE_MODE_MAP);

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryAction.js
var DeliveryAction = class extends Action {
  /**
   * @param {string} deliveryKey A generic Delivery Action Key (such as q, f, dn, etc.)
   * @param {string} deliveryType A Format Qualifiers for the action, such as Quality.auto()
   * @param {string} modelProperty internal model property of the action, for example quality uses `level` while dpr uses `density`
   * @see Visit {@link Actions.Delivery|Delivery} for an example
   */
  constructor(deliveryKey, deliveryType, modelProperty) {
    super();
    this._actionModel = {};
    let deliveryTypeValue;
    if (deliveryType instanceof FormatQualifier) {
      deliveryTypeValue = deliveryType.getValue();
    } else {
      deliveryTypeValue = deliveryType;
    }
    this._actionModel.actionType = DELIVERY_MODE_TO_ACTION_TYPE_MAP[deliveryKey];
    this._actionModel[modelProperty] = deliveryTypeValue;
    this.addQualifier(new Qualifier(deliveryKey, deliveryType));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/progressive.js
var ProgressiveQualifier = class extends FlagQualifier {
  constructor(mode2) {
    super("progressive", mode2);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryFormatAction.js
var DeliveryFormatAction = class extends DeliveryAction {
  constructor(deliveryKey, deliveryType) {
    super(deliveryKey, deliveryType, "formatType");
  }
  /**
   * @description Uses lossy compression when delivering animated GIF files.
   * @return {this}
   */
  lossy() {
    this._actionModel.lossy = true;
    this.addFlag(lossy());
    return this;
  }
  /**
   * @description Uses progressive compression when delivering JPG file format.
   * @return {this}
   */
  progressive(mode2) {
    if (mode2 instanceof ProgressiveQualifier) {
      this._actionModel.progressive = { mode: mode2.getFlagValue() };
      this.addFlag(mode2);
    } else {
      this._actionModel.progressive = { mode: mode2 };
      this.addFlag(progressive(mode2));
    }
    return this;
  }
  /**
   * @description Ensures that images with a transparency channel are delivered in PNG format.
   */
  preserveTransparency() {
    this._actionModel.preserveTransparency = true;
    this.addFlag(preserveTransparency());
    return this;
  }
  static fromJson(actionModel) {
    const { formatType, lossy: lossy2, progressive: progressive2, preserveTransparency: preserveTransparency2 } = actionModel;
    let result;
    if (formatType) {
      result = new this("f", formatType);
    } else {
      result = new this("f");
    }
    if (progressive2) {
      if (progressive2.mode) {
        result.progressive(progressive2.mode);
      } else {
        result.progressive();
      }
    }
    lossy2 && result.lossy();
    preserveTransparency2 && result.preserveTransparency();
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/transformation/Transformation.js
var Transformation = class _Transformation {
  constructor() {
    this.actions = [];
  }
  /**
   * @param {SDK.Action | string} action
   * @return {this}
   */
  addAction(action) {
    let actionToAdd;
    if (typeof action === "string") {
      if (action.indexOf("/") >= 0) {
        throw "addAction cannot accept a string with a forward slash in it - /, use .addTransformation() instead";
      } else {
        actionToAdd = new RawAction(action);
      }
    } else {
      actionToAdd = action;
    }
    this.actions.push(actionToAdd);
    return this;
  }
  /**
   * @description Allows the injection of a raw transformation as a string into the transformation, or a Transformation instance that was previously created
   * @param {string | SDK.Transformation} tx
   * @example
   * import {Transformation} from "@cloudinary/url-gen";
   *
   * const transformation = new Transformation();
   * transformation.addTransformation('w_100/w_200/w_300');
   * @return {this}
   */
  addTransformation(tx) {
    if (tx instanceof _Transformation) {
      this.actions = this.actions.concat(tx.actions);
    } else {
      this.actions.push(new RawAction(tx));
    }
    return this;
  }
  /**
   * @return {string}
   */
  toString() {
    return this.actions.map((action) => {
      return action.toString();
    }).filter((a) => a).join("/");
  }
  /**
   * @description Delivers an animated GIF.
   * @param {AnimatedAction} animatedAction
   * @return {this}
   */
  animated(animatedAction) {
    return this.addAction(animatedAction);
  }
  /**
   * @description Adds a border around the image.
   * @param {Border} borderAction
   * @return {this}
   */
  border(borderAction) {
    return this.addAction(borderAction);
  }
  /**
   * @description Adjusts the shape of the delivered image. </br>
   * <b>Learn more:</b> {@link https://cloudinary.com/documentation/effects_and_artistic_enhancements#distort|Shape changes and distortion effects}
   * @param {IReshape} reshapeAction
   * @return {this}
   */
  reshape(reshapeAction) {
    return this.addAction(reshapeAction);
  }
  /**
   * @description Resize the asset using provided resize action
   * @param {ResizeSimpleAction} resizeAction
   * @return {this}
   */
  resize(resizeAction) {
    return this.addAction(resizeAction);
  }
  /**
   * @desc An alias to Action Delivery.quality
   * @param {string|number} quality
   * @return {this}
   */
  quality(quality2) {
    this.addAction(new DeliveryFormatAction("q", quality2));
    return this;
  }
  /**
   * @desc An alias to Action Delivery.format
   * @param {string} format
   * @return {this}
   */
  format(format2) {
    this.addAction(new DeliveryFormatAction("f", format2));
    return this;
  }
  /**
   * @description Rounds the specified corners of an image.
   * @param roundCornersAction
   * @return {this}
   */
  roundCorners(roundCornersAction) {
    return this.addAction(roundCornersAction);
  }
  /**
   * @description Adds an overlay over the base image.
   * @param {LayerAction} overlayAction
   * @return {this}
   */
  overlay(overlayAction) {
    return this.addAction(overlayAction);
  }
  /**
   * @description Adds an underlay under the base image.
   * @param {LayerAction} underlayAction
   * @return {this}
   */
  underlay(underlayAction) {
    underlayAction.setLayerType("u");
    return this.addAction(underlayAction);
  }
  /**
   * @description Defines an new user variable.
   * @param {VariableAction} variableAction
   * @return {this}
   */
  addVariable(variableAction) {
    return this.addAction(variableAction);
  }
  /**
   * @description Specifies a condition to be met before applying a transformation.
   * @param {ConditionalAction} conditionAction
   * @return {this}
   */
  conditional(conditionAction) {
    return this.addAction(conditionAction);
  }
  /**
   * @description Applies a filter or an effect on an asset.
   * @param {SimpleEffectAction} effectAction
   * @return {this}
   */
  effect(effectAction) {
    return this.addAction(effectAction);
  }
  /**
   * @description Applies adjustment effect on an asset.
   * @param action
   * @return {this}
   */
  adjust(action) {
    return this.addAction(action);
  }
  /**
   * @description Rotates the asset by the given angle.
   * @param {RotateAction} rotateAction
   * @return {this}
   */
  rotate(rotateAction) {
    return this.addAction(rotateAction);
  }
  /**
   * @description Applies a pre-defined named transformation of the given name.
   * @param {NamedTransformation} namedTransformation
   * @return {this}
   */
  namedTransformation(namedTransformation) {
    return this.addAction(namedTransformation);
  }
  /**
   * @description Applies delivery action.
   * @param deliveryAction
   * @return {this}
   */
  delivery(deliveryAction) {
    return this.addAction(deliveryAction);
  }
  /**
   * @description Sets the color of the background.
   * @param {Qualifiers.Color} color
   * @return {this}
   */
  backgroundColor(color2) {
    return this.addAction(new BackgroundColor(prepareColor(color2)));
  }
  /**
   * @description Adds a layer in a Photoshop document.
   * @param action
   * @return {this}
   */
  psdTools(action) {
    return this.addAction(action);
  }
  /**
   * @description Extracts an image or a page using an index, a range, or a name from a layered media asset.
   * @param action
   * @return {this}
   */
  extract(action) {
    return this.addAction(action);
  }
  /**
   * @description Adds a flag as a separate action.
   * @param {Qualifiers.Flag | string} flagQualifier
   * @return {this}
   */
  addFlag(flagQualifier) {
    const action = new Action();
    let flagToAdd = flagQualifier;
    if (typeof flagQualifier === "string") {
      flagToAdd = new FlagQualifier(flagQualifier);
    }
    action.addQualifier(flagToAdd);
    return this.addAction(action);
  }
  /**
   * @description Inject a custom function into the image transformation pipeline.
   * @return {this}
   */
  customFunction(customFunction) {
    return this.addAction(customFunction);
  }
  /**
   * Transcodes the video (or audio) to another format.
   * @param {Action} action
   * @return {this}
   */
  transcode(action) {
    return this.addAction(action);
  }
  /**
   * Applies the specified video edit action.
   *
   * @param {videoEditType} action
   * @return {this}
   */
  videoEdit(action) {
    return this.addAction(action);
  }
  toJson() {
    const actions = [];
    for (const action of this.actions) {
      const json = action.toJson();
      if (isErrorObject(json)) {
        return json;
      }
      actions.push(json);
    }
    return { actions };
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/transformation/ImageTransformation.js
var ImageTransformation = class extends Transformation {
};

// node_modules/@cloudinary/transformation-builder-sdk/transformation/VideoTransformation.js
var VideoTransformation = class extends Transformation {
};

// node_modules/@cloudinary/transformation-builder-sdk/backwards/consts.js
var NUMBER_PATTERN = "([0-9]*)\\.([0-9]+)|([0-9]+)";
var OFFSET_ANY_PATTERN = `(${NUMBER_PATTERN})([%pP])?`;
var RANGE_VALUE_RE = RegExp(`^${OFFSET_ANY_PATTERN}$`);
var OFFSET_ANY_PATTERN_RE = RegExp(`(${OFFSET_ANY_PATTERN})\\.\\.(${OFFSET_ANY_PATTERN})`);

// node_modules/@cloudinary/transformation-builder-sdk/backwards/utils/snakeCase.js
var snakeCase = (str) => str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/cloneDeep.js
var LARGE_ARRAY_SIZE = 200;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var promiseTag = "[object Promise]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var symbolTag = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!`${value}`;
    } catch (e) {
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var arrayProto = Array.prototype;
var funcProto = Function.prototype;
var objectProto = Object.prototype;
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? `Symbol(src)_1.${uid}` : "";
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp(`^${funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?")}$`);
var Buffer = moduleExports ? root.Buffer : void 0;
var Symbol = root.Symbol;
var Uint8Array = root.Uint8Array;
var getPrototype = overArg(Object.getPrototypeOf, Object);
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
var splice = arrayProto.splice;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var nativeKeys = overArg(Object.keys, Object);
var DataView = getNative(root, "DataView");
var Map2 = getNative(root, "Map");
var Promise2 = getNative(root, "Promise");
var Set = getNative(root, "Set");
var WeakMap = getNative(root, "WeakMap");
var nativeCreate = getNative(Object, "create");
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map2);
var promiseCtorString = toSource(Promise2);
var setCtorString = toSource(Set);
var weakMapCtorString = toSource(WeakMap);
var symbolProto = Symbol ? Symbol.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function Hash(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : void 0;
}
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
}
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear() {
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map2 || ListCache)(),
    "string": new Hash()
  };
}
function mapCacheDelete(key) {
  return getMapData(this, key).delete(key);
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}
function stackClear() {
  this.__data__ = new ListCache();
}
function stackDelete(key) {
  return this.__data__.delete(key);
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseGetTag(value) {
  return objectToString.call(value);
}
function baseIsNative(value) {
  if (!isObject3(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function(value) {
    var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return `${func}`;
    } catch (e) {
    }
  }
  return "";
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var isArray = Array.isArray;
function isFunction(value) {
  var tag = isObject3(value) ? objectToString.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isObject3(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function stubArray() {
  return [];
}

// node_modules/@cloudinary/transformation-builder-sdk/backwards/configuration.js
var DEFAULT_CONFIGURATION_PARAMS = {
  responsive_class: "cld-responsive",
  responsive_use_breakpoints: true,
  round_dpr: true,
  secure: (typeof window !== "undefined" && window !== null ? window.location ? window.location.protocol : void 0 : void 0) === "https:"
};
var CONFIG_PARAMS = [
  "api_key",
  "api_secret",
  "callback",
  "cdn_subdomain",
  "cloud_name",
  "cname",
  "private_cdn",
  "protocol",
  "resource_type",
  "responsive",
  "responsive_class",
  "responsive_use_breakpoints",
  "responsive_width",
  "round_dpr",
  "secure",
  "secure_cdn_subdomain",
  "secure_distribution",
  "shorten",
  "type",
  "upload_preset",
  "url_suffix",
  "use_root_path",
  "version",
  "externalLibraries",
  "max_timeout_ms"
];

// node_modules/@cloudinary/transformation-builder-sdk/backwards/utils/legacyBaseUtil.js
var reWords = function() {
  var lower, upper;
  upper = "[A-Z]";
  lower = "[a-z]+";
  return RegExp(upper + "+(?=" + upper + lower + ")|" + upper + "?" + lower + "|" + upper + "+|[0-9]+", "g");
}();

// node_modules/@cloudinary/transformation-builder-sdk/backwards/transformation.js
var number_pattern = "([0-9]*)\\.([0-9]+)|([0-9]+)";
var offset_any_pattern = "(" + number_pattern + ")([%pP])?";
var methods = [
  "angle",
  "audioCodec",
  "audioFrequency",
  "aspectRatio",
  "background",
  "bitRate",
  "border",
  "color",
  "colorSpace",
  "crop",
  "customFunction",
  "customPreFunction",
  "defaultImage",
  "delay",
  "density",
  "duration",
  "dpr",
  "effect",
  "else",
  "endIf",
  "endOffset",
  "fallbackContent",
  "fetchFormat",
  "format",
  "flags",
  "gravity",
  "fps",
  "height",
  "htmlHeight",
  "htmlWidth",
  "if",
  "keyframeInterval",
  "ocr",
  "offset",
  "opacity",
  "overlay",
  "page",
  "poster",
  "prefix",
  "quality",
  "radius",
  "rawTransformation",
  "size",
  "sourceTypes",
  "sourceTransformation",
  "startOffset",
  "streamingProfile",
  "transformation",
  "underlay",
  "variable",
  "variables",
  "videoCodec",
  "videoSampling",
  "width",
  "x",
  "y",
  "zoom"
];
var PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/autoFocus.js
var AutoFocus = class _AutoFocus extends QualifierValue {
  constructor(focusOn3, weight) {
    super();
    this._weight = weight;
    this.focusOn = focusOn3;
    this.shouldAvoid = false;
  }
  /**
   * @summary qualifier
   * @description Specifies the object to focus on automatically
   * Accepts an AutoFocusObject (which is just a wrapper for a FocusOn object, but with extra method: avoid, weight)
   * @param {Qualifiers.FocusOn} obj The object to focus on.
   * @param {number} weight
   */
  static focusOn(obj, weight) {
    return new _AutoFocus(obj, weight);
  }
  shouldAddWeight() {
    return typeof this._weight === "number" || typeof this._weight === "string" || this.shouldAvoid;
  }
  /**
   * @summary qualifier
   * @desc Get the name of the of the object
   */
  getName() {
    return this.focusOn.name;
  }
  /**
   * @summary qualifier
   * @desc Get the weight for the object
   */
  getWeight() {
    if (this.shouldAvoid) {
      return "avoid";
    } else {
      return this._weight;
    }
  }
  /**
   * @summary qualifier
   * @desc Return the string representation of this QualifierValue
   */
  toString() {
    if (this.shouldAddWeight()) {
      return `${this.getName()}_${this.getWeight()}`;
    } else {
      return `${this.getName()}`;
    }
  }
  /**
   * @summary qualifier
   * @description Sets the importance level of the object within the automatic gravity algorithm
   * @param {numebr} w The focus weight for the object
   * @return {this}
   */
  weight(w) {
    this._weight = w;
    return this;
  }
  /**
   * @summary qualifier
   * @description Attempts to avoid the detected object in the image
   * @return {this}
   */
  avoid() {
    this.shouldAvoid = true;
    return this;
  }
};
var focusOn = AutoFocus.focusOn;

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/videoCodecType/VideoCodecType.js
var VideoCodecType = class extends Qualifier {
  constructor(type) {
    super("vc");
    this._type = type;
    this.addValue(type);
  }
  getType() {
    return this._type;
  }
};
var AdvVideoCodecType = class extends Qualifier {
  constructor(type) {
    super("vc");
    this._type = type;
  }
  getType() {
    return this._type;
  }
  /**
   * @description Specifies the profile to use with the h264 codec.
   * @param {Qualifiers.VideoCodecProfile | string} profile Sets the profile of the video codec
   * @example new AdvVideoCodecType('h264').profile(VideoCodecProfile.baseline())
   * @return this;
   */
  profile(profile) {
    this._prof = profile;
    return this;
  }
  getProfile() {
    return this._prof;
  }
  /**
   * @description Specifies the level to use with the h264 codec and specified profile.
   * @param {Qualifiers.VideoCodecLevel | number | string} lvl
   * @example new AdvVideoCodecType('h264').profile(VideoCodecLevel.baseline())
   * @return this;
   */
  level(lvl) {
    this._lvl = lvl;
    return this;
  }
  getLevel() {
    return this._lvl;
  }
  /**
   * @description returns a toString representation of this qualifier
   * @return string;
   */
  toString() {
    return `vc_${this._type}:${this._prof}:${this._lvl}`;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/videoCodec.js
function auto2() {
  return new VideoCodecType("auto");
}
function h264() {
  return new AdvVideoCodecType("h264");
}
function h265() {
  return new VideoCodecType("h265");
}
function proRes() {
  return new VideoCodecType("prores");
}
function theora() {
  return new VideoCodecType("theora");
}
function vp8() {
  return new VideoCodecType("vp8");
}
function vp9() {
  return new VideoCodecType("vp9");
}
var VIDEO_CODEC_TO_TRANSFORMATION = {
  "auto": auto2(),
  "h264": h264(),
  "h265": h265(),
  "prores": proRes(),
  "theora": theora(),
  "vp8": vp8(),
  "vp9": vp9()
};

// node_modules/@cloudinary/url-gen/internal/url/urlUtils/isUrl.js
function isUrl(publicID) {
  return publicID.match(/^https?:\//);
}

// node_modules/@cloudinary/url-gen/internal/url/urlUtils/isFileName.js
function isFileName(publicID) {
  return publicID.indexOf("/") < 0;
}

// node_modules/@cloudinary/url-gen/internal/url/urlUtils/publicIDContainsVersion.js
function publicIDContainsVersion(publicID) {
  return publicID.match(/^v[0-9]+/);
}

// node_modules/@cloudinary/url-gen/internal/url/cloudinaryURL.js
function getUrlPrefix(cloudName, urlConfig) {
  const secure = urlConfig.secure;
  const privateCDN = urlConfig.privateCdn;
  const cname = urlConfig.cname;
  const secureDistribution = urlConfig.secureDistribution;
  if (!secure && !cname) {
    return `http://res.cloudinary.com/${cloudName}`;
  }
  if (secure && !secureDistribution && privateCDN) {
    return `https://${cloudName}-res.cloudinary.com`;
  }
  if (secure && !secureDistribution) {
    return `https://res.cloudinary.com/${cloudName}`;
  }
  if (secure && secureDistribution && privateCDN) {
    return `https://${secureDistribution}`;
  }
  if (secure && secureDistribution) {
    return `https://${secureDistribution}/${cloudName}`;
  }
  if (!secure && cname) {
    return `http://${cname}/${cloudName}`;
  } else {
    return "ERROR";
  }
}
function handleAssetType(assetType) {
  if (!assetType) {
    return "image";
  }
  return assetType;
}
function handleDeliveryType(deliveryType) {
  if (!deliveryType) {
    return "upload";
  }
  return deliveryType;
}
function getUrlVersion(publicID, version, forceVersion) {
  const shouldForceVersion = forceVersion !== false;
  if (version) {
    return `v${version}`;
  }
  if (publicIDContainsVersion(publicID) || isUrl(publicID) || isFileName(publicID)) {
    return "";
  }
  return shouldForceVersion ? "v1" : "";
}

// node_modules/@cloudinary/url-gen/sdkAnalytics/stringPad.js
function stringPad(value, _targetLength, _padString) {
  let targetLength = _targetLength >> 0;
  let padString = String(typeof _padString !== "undefined" ? _padString : " ");
  if (value.length > targetLength) {
    return String(value);
  } else {
    targetLength = targetLength - value.length;
    if (targetLength > padString.length) {
      padString += repeatStringNumTimes(padString, targetLength / padString.length);
    }
    return padString.slice(0, targetLength) + String(value);
  }
}
function repeatStringNumTimes(string, _times) {
  let times = _times;
  let repeatedString = "";
  while (times > 0) {
    repeatedString += string;
    times--;
  }
  return repeatedString;
}

// node_modules/@cloudinary/url-gen/sdkAnalytics/base64Map.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base64Map = {};
var num = 0;
chars.split("").forEach((char) => {
  let key = num.toString(2);
  key = stringPad(key, 6, "0");
  base64Map[key] = char;
  num++;
});

// node_modules/@cloudinary/url-gen/sdkAnalytics/reverseVersion.js
function reverseVersion(semVer) {
  if (semVer.split(".").length < 2) {
    throw new Error("invalid semVer, must have at least two segments");
  }
  return semVer.split(".").reverse().map((segment) => {
    const asNumber = +segment;
    if (isNaN(asNumber) || asNumber < 0) {
      throw "Invalid version number provided";
    }
    return stringPad(segment, 2, "0");
  }).join(".");
}

// node_modules/@cloudinary/url-gen/sdkAnalytics/encodeVersion.js
function encodeVersion(semVer) {
  let strResult = "";
  const parts = semVer.split(".").length;
  const paddedStringLength = parts * 6;
  const paddedReversedSemver = reverseVersion(semVer);
  const num2 = parseInt(paddedReversedSemver.split(".").join(""));
  let paddedBinary = num2.toString(2);
  paddedBinary = stringPad(paddedBinary, paddedStringLength, "0");
  if (paddedBinary.length % 6 !== 0) {
    throw "Version must be smaller than 43.21.26)";
  }
  paddedBinary.match(/.{1,6}/g).forEach((bitString) => {
    strResult += base64Map[bitString];
  });
  return strResult;
}

// node_modules/@cloudinary/url-gen/sdkAnalytics/getAnalyticsOptions.js
function getAnalyticsOptions(options) {
  const analyticsOptions = {
    sdkSemver: options.sdkSemver,
    techVersion: options.techVersion,
    sdkCode: options.sdkCode,
    product: options.product,
    feature: "0"
  };
  if (options.accessibility) {
    analyticsOptions.feature = "D";
  }
  if (options.lazyload) {
    analyticsOptions.feature = "C";
  }
  if (options.responsive) {
    analyticsOptions.feature = "A";
  }
  if (options.placeholder) {
    analyticsOptions.feature = "B";
  }
  return analyticsOptions;
}

// node_modules/@cloudinary/url-gen/internal/utils/packageVersion.js
var packageVersion = "1.11.0";

// node_modules/@cloudinary/url-gen/sdkAnalytics/getSDKAnalyticsSignature.js
function getNodeVersion() {
  const failedVersion = "0.0.0";
  if (typeof window !== "undefined") {
    return failedVersion;
  } else {
    try {
      return process.versions.node || failedVersion;
    } catch (e) {
      return failedVersion;
    }
  }
}
function ensureShapeOfTrackedProperties(trackedAnalytics) {
  const defaults = {
    techVersion: getNodeVersion(),
    sdkCode: "T",
    sdkSemver: packageVersion.split("-")[0],
    product: "A",
    responsive: false,
    placeholder: false,
    lazyload: false,
    accessibility: false
  };
  if (!trackedAnalytics) {
    return defaults;
  } else {
    return Object.assign(Object.assign({}, defaults), trackedAnalytics);
  }
}
function getSDKAnalyticsSignature(_trackedAnalytics) {
  const trackedAnalytics = ensureShapeOfTrackedProperties(_trackedAnalytics);
  const analyticsOptions = getAnalyticsOptions(trackedAnalytics);
  try {
    const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);
    const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);
    const encodedTechVersion = encodeVersion(twoPartVersion);
    const featureCode = analyticsOptions.feature;
    const SDKCode = analyticsOptions.sdkCode;
    const product = analyticsOptions.product;
    const algoVersion = "B";
    return `${algoVersion}${product}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${featureCode}`;
  } catch (e) {
    return "E";
  }
}
function removePatchFromSemver(semVerStr) {
  const parts = semVerStr.split(".");
  return `${parts[0]}.${parts[1]}`;
}

// node_modules/@cloudinary/url-gen/assets/CloudinaryFile.js
var SEO_TYPES = {
  "image/upload": "images",
  "image/private": "private_images",
  "image/authenticated": "authenticated_images",
  "raw/upload": "files",
  "video/upload": "videos"
};
var CloudinaryFile = class {
  constructor(publicID, cloudConfig = {}, urlConfig) {
    this.setPublicID(publicID);
    this.setCloudConfig(cloudConfig);
    this.setURLConfig(urlConfig);
  }
  /**
   * @description Sets the URL Config for this asset
   * @param urlConfig
   * @return {this}
   */
  setURLConfig(urlConfig) {
    this.urlConfig = new URLConfig_default(urlConfig);
    return this;
  }
  /**
   * @description Sets the Cloud Config for this asset
   * @param urlConfig
   * @return {this}
   */
  setCloudConfig(cloudConfig) {
    this.cloudName = cloudConfig.cloudName;
    this.apiKey = cloudConfig.apiKey;
    this.apiSecret = cloudConfig.apiSecret;
    this.authToken = cloudConfig.authToken;
    return this;
  }
  /**
   * @description Sets the public ID of the asset.
   * @param {string} publicID The public ID of the asset.
   * @return {this}
   */
  setPublicID(publicID) {
    this.publicID = publicID ? publicID.toString() : "";
    return this;
  }
  /**
   * @description Sets the delivery type of the asset.
   * @param {DELIVERY_TYPE | string} newType The type of the asset.
   * @return {this}
   */
  setDeliveryType(newType) {
    this.deliveryType = newType;
    return this;
  }
  /**
   * @description Sets the URL SEO suffix of the asset.
   * @param {string} newSuffix The SEO suffix.
   * @return {this}
   */
  setSuffix(newSuffix) {
    this.suffix = newSuffix;
    return this;
  }
  /**
   * @description Sets the signature of the asset.
   * @param {string} signature The signature.
   * @return {this}
   */
  setSignature(signature) {
    this.signature = signature;
    return this;
  }
  /**
   * @description Sets the version of the asset.
   * @param {string} newVersion The version of the asset.
   * @return {this}
   */
  setVersion(newVersion) {
    if (newVersion) {
      this.version = newVersion;
    }
    return this;
  }
  /**
   * @description Sets the asset type.
   * @param {string} newType The type of the asset.
   * @return {this}
   */
  setAssetType(newType) {
    if (newType) {
      this.assetType = newType;
    }
    return this;
  }
  sign() {
    return this;
  }
  /**
   * @description Serializes to URL string
   * @param overwriteOptions
   */
  toURL(overwriteOptions = {}) {
    return this.createCloudinaryURL(null, overwriteOptions.trackedAnalytics);
  }
  /**
   * @description Validate various options before attempting to create a URL
   * The function will throw in case a violation
   * @throws Validation errors
   */
  validateAssetForURLCreation() {
    if (typeof this.cloudName === "undefined") {
      throw "You must supply a cloudName when initializing the asset";
    }
    const suffixContainsDot = this.suffix && this.suffix.indexOf(".") >= 0;
    const suffixContainsSlash = this.suffix && this.suffix.indexOf("/") >= 0;
    if (suffixContainsDot || suffixContainsSlash) {
      throw "`suffix`` should not include . or /";
    }
  }
  /**
   * @description return an SEO friendly name for a combination of asset/delivery, some examples:
   * * image/upload -> images
   * * video/upload -> videos
   * If no match is found, return `{asset}/{delivery}`
   */
  getResourceType() {
    const assetType = handleAssetType(this.assetType);
    const deliveryType = handleDeliveryType(this.deliveryType);
    const hasSuffix = !!this.suffix;
    const regularSEOType = `${assetType}/${deliveryType}`;
    const shortSEOType = SEO_TYPES[`${assetType}/${deliveryType}`];
    const useRootPath = this.urlConfig.useRootPath;
    const shorten = this.urlConfig.shorten;
    if (useRootPath) {
      if (regularSEOType === "image/upload") {
        return "";
      } else {
        throw new Error(`useRootPath can only be used with assetType: 'image' and deliveryType: 'upload'. Provided: ${regularSEOType} instead`);
      }
    }
    if (shorten && regularSEOType === "image/upload") {
      return "iu";
    }
    if (hasSuffix) {
      if (shortSEOType) {
        return shortSEOType;
      } else {
        throw new Error(`URL Suffix only supported for ${Object.keys(SEO_TYPES).join(", ")}, Provided: ${regularSEOType} instead`);
      }
    }
    return regularSEOType;
  }
  getSignature() {
    if (this.signature) {
      return `s--${this.signature}--`;
    } else {
      return "";
    }
  }
  /**
   *
   * @description Creates a fully qualified CloudinaryURL
   * @return {string} CloudinaryURL
   * @throws Validation Errors
   */
  createCloudinaryURL(transformation, trackedAnalytics) {
    if (!this.publicID) {
      return "";
    }
    this.validateAssetForURLCreation();
    const prefix = getUrlPrefix(this.cloudName, this.urlConfig);
    const transformationString = transformation ? transformation.toString() : "";
    const version = getUrlVersion(this.publicID, this.version, this.urlConfig.forceVersion);
    const publicID = this.publicID.replace(/,/g, "%2C");
    const url = [prefix, this.getResourceType(), this.getSignature(), transformationString, version, publicID, this.suffix].filter((a) => a).join("/");
    if (typeof transformation === "string") {
      return url;
    } else {
      const safeURL = encodeURI(url).replace(/\?/g, "%3F").replace(/=/g, "%3D");
      const queryParams = new URLSearchParams(this.urlConfig.queryParams);
      if (this.urlConfig.analytics !== false && !publicID.includes("?")) {
        queryParams.set("_a", getSDKAnalyticsSignature(trackedAnalytics));
      }
      const queryParamsString = queryParams.toString();
      if (queryParamsString) {
        return `${safeURL}?${queryParamsString}`;
      } else {
        return safeURL;
      }
    }
  }
};

// node_modules/@cloudinary/url-gen/assets/CloudinaryTransformable.js
var CloudinaryTransformable = class extends CloudinaryFile {
  constructor(publicID, cloudConfig, urlConfig, transformation) {
    super(publicID, cloudConfig, urlConfig);
    this.transformation = transformation;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Animated} animated
   * @return {this}
   */
  animated(animated2) {
    this.transformation.animated(animated2);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Border} border
   * @return {this}
   */
  border(border2) {
    this.transformation.border(border2);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Reshape} reshape
   * @return {this}
   */
  reshape(reshape) {
    this.transformation.reshape(reshape);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Resize} resize
   * @return {this}
   */
  resize(resize) {
    this.transformation.resize(resize);
    return this;
  }
  /**
   * @desc An alias to Action Delivery.quality
   * @param {string|number} quality
   * @return {this}
   */
  quality(quality2) {
    this.addAction(new DeliveryFormatAction("q", quality2));
    return this;
  }
  /**
   * @desc An alias to Action Delivery.format
   * @param {string} format
   * @return {this}
   */
  format(format2) {
    this.addAction(new DeliveryFormatAction("f", format2));
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.RoundCorners} roundCorners
   * @return {this}
   */
  roundCorners(roundCorners) {
    this.transformation.roundCorners(roundCorners);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @return {this}
   */
  overlay(overlayAction) {
    this.transformation.overlay(overlayAction);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Variable} variableAction
   * @return {this}
   */
  addVariable(variableAction) {
    this.transformation.addVariable(variableAction);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Condition} conditionalAction
   * @return {this}
   */
  conditional(conditionalAction) {
    this.transformation.conditional(conditionalAction);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Effect} effect
   * @return {this}
   */
  effect(effect) {
    this.transformation.effect(effect);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Adjust} action
   * @return {this}
   */
  adjust(action) {
    this.transformation.adjust(action);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Rotate} rotate
   * @return {this}
   */
  rotate(rotate) {
    this.transformation.rotate(rotate);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.NamedTransformation} namedTransformation
   * @return {this}
   */
  namedTransformation(namedTransformation) {
    this.transformation.namedTransformation(namedTransformation);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Delivery} deliveryAction
   * @return {this}
   */
  delivery(deliveryAction) {
    this.transformation.delivery(deliveryAction);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Qualifiers.color} color
   * @return {this}
   */
  backgroundColor(color2) {
    this.transformation.backgroundColor(color2);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.PSDTools} action
   * @return {this}
   */
  psdTools(action) {
    this.transformation.psdTools(action);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Extract} action
   * @return {this}
   */
  extract(action) {
    this.transformation.extract(action);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Qualifiers.Flag | string} flagQualifier
   * @return {this}
   */
  addFlag(flagQualifier) {
    this.transformation.addFlag(flagQualifier);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.CustomFunction} customFunction
   * @return {this}
   */
  customFunction(customFunction) {
    this.transformation.customFunction(customFunction);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {SDK.Action | string} action
   * @return {this}
   */
  addAction(action) {
    this.transformation.addAction(action);
    return this;
  }
  /**
   * @description Extend your transformation with another transformation
   * @param { string | SDK.Transformation } tx
   */
  addTransformation(tx) {
    this.transformation.addTransformation(tx);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @return {string}
   */
  toString() {
    return this.transformation.toString();
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @return {this}
   */
  underlay(underlayAction) {
    this.transformation.underlay(underlayAction);
    return this;
  }
  toURL(overwriteOptions = {}) {
    return this.createCloudinaryURL(this.transformation, overwriteOptions === null || overwriteOptions === void 0 ? void 0 : overwriteOptions.trackedAnalytics);
  }
};

// node_modules/@cloudinary/url-gen/assets/CloudinaryImage.js
var CloudinaryImage = class extends CloudinaryTransformable {
  constructor(publicID, cloudConfig, urlConfig) {
    super(publicID, cloudConfig, urlConfig, new ImageTransformation());
  }
};

// node_modules/@cloudinary/url-gen/assets/CloudinaryVideo.js
var CloudinaryVideo = class extends CloudinaryTransformable {
  constructor(publicID, cloudConfig, urlConfig) {
    super(publicID, cloudConfig, urlConfig, new VideoTransformation());
    this.assetType = "video";
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Transcode} action
   * @return {this}
   */
  transcode(action) {
    this.transformation.transcode(action);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.VideoEdit} action
   * @return {this}
   */
  videoEdit(action) {
    this.transformation.videoEdit(action);
    return this;
  }
};

// node_modules/@cloudinary/url-gen/internal/utils/cloneDeep.js
var LARGE_ARRAY_SIZE2 = 200;
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
var argsTag2 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag2 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag2 = "[object Map]";
var numberTag2 = "[object Number]";
var objectTag2 = "[object Object]";
var promiseTag2 = "[object Promise]";
var regexpTag2 = "[object RegExp]";
var setTag2 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var weakMapTag2 = "[object WeakMap]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag2 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
var cloneableTags2 = {};
cloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag2] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag2] = cloneableTags2[float64Tag2] = cloneableTags2[int8Tag2] = cloneableTags2[int16Tag2] = cloneableTags2[int32Tag2] = cloneableTags2[mapTag2] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag2] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag2] = cloneableTags2[uint8ClampedTag2] = cloneableTags2[uint16Tag2] = cloneableTags2[uint32Tag2] = true;
cloneableTags2[errorTag2] = cloneableTags2[funcTag2] = cloneableTags2[weakMapTag2] = false;
var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
function getValue2(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject2(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!`${value}`;
    } catch (e) {
    }
  }
  return result;
}
function overArg2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var arrayProto2 = Array.prototype;
var funcProto2 = Function.prototype;
var objectProto2 = Object.prototype;
var coreJsData2 = root2["__core-js_shared__"];
var maskSrcKey2 = function() {
  var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
  return uid ? `Symbol(src)_1.${uid}` : "";
}();
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto2.hasOwnProperty;
var objectToString2 = objectProto2.toString;
var reIsNative2 = RegExp(`^${funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?")}$`);
var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
var Symbol2 = root2.Symbol;
var Uint8Array2 = root2.Uint8Array;
var getPrototype2 = overArg2(Object.getPrototypeOf, Object);
var propertyIsEnumerable2 = objectProto2.propertyIsEnumerable;
var splice2 = arrayProto2.splice;
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
var nativeKeys2 = overArg2(Object.keys, Object);
var DataView2 = getNative2(root2, "DataView");
var Map3 = getNative2(root2, "Map");
var Promise3 = getNative2(root2, "Promise");
var Set2 = getNative2(root2, "Set");
var WeakMap2 = getNative2(root2, "WeakMap");
var nativeCreate2 = getNative2(Object, "create");
var dataViewCtorString2 = toSource2(DataView2);
var mapCtorString2 = toSource2(Map3);
var promiseCtorString2 = toSource2(Promise3);
var setCtorString2 = toSource2(Set2);
var weakMapCtorString2 = toSource2(WeakMap2);
var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0;
var symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
function Hash2(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function hashClear2() {
  this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
}
function hashDelete2(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet2(key) {
  var data = this.__data__;
  if (nativeCreate2) {
    var result = data[key];
    return result === HASH_UNDEFINED2 ? void 0 : result;
  }
  return hasOwnProperty2.call(data, key) ? data[key] : void 0;
}
function hashHas2(key) {
  var data = this.__data__;
  return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
}
function hashSet2(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
Hash2.prototype.clear = hashClear2;
Hash2.prototype.delete = hashDelete2;
Hash2.prototype.get = hashGet2;
Hash2.prototype.has = hashHas2;
Hash2.prototype.set = hashSet2;
function ListCache2(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear2() {
  this.__data__ = [];
}
function listCacheDelete2(key) {
  var data = this.__data__, index = assocIndexOf2(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice2.call(data, index, 1);
  }
  return true;
}
function listCacheGet2(key) {
  var data = this.__data__, index = assocIndexOf2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas2(key) {
  return assocIndexOf2(this.__data__, key) > -1;
}
function listCacheSet2(key, value) {
  var data = this.__data__, index = assocIndexOf2(data, key);
  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
ListCache2.prototype.clear = listCacheClear2;
ListCache2.prototype.delete = listCacheDelete2;
ListCache2.prototype.get = listCacheGet2;
ListCache2.prototype.has = listCacheHas2;
ListCache2.prototype.set = listCacheSet2;
function MapCache2(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear2() {
  this.__data__ = {
    "hash": new Hash2(),
    "map": new (Map3 || ListCache2)(),
    "string": new Hash2()
  };
}
function mapCacheDelete2(key) {
  return getMapData2(this, key).delete(key);
}
function mapCacheGet2(key) {
  return getMapData2(this, key).get(key);
}
function mapCacheHas2(key) {
  return getMapData2(this, key).has(key);
}
function mapCacheSet2(key, value) {
  getMapData2(this, key).set(key, value);
  return this;
}
MapCache2.prototype.clear = mapCacheClear2;
MapCache2.prototype.delete = mapCacheDelete2;
MapCache2.prototype.get = mapCacheGet2;
MapCache2.prototype.has = mapCacheHas2;
MapCache2.prototype.set = mapCacheSet2;
function Stack2(entries) {
  this.__data__ = new ListCache2(entries);
}
function stackClear2() {
  this.__data__ = new ListCache2();
}
function stackDelete2(key) {
  return this.__data__.delete(key);
}
function stackGet2(key) {
  return this.__data__.get(key);
}
function stackHas2(key) {
  return this.__data__.has(key);
}
function stackSet2(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache2) {
    var pairs = cache.__data__;
    if (!Map3 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache2(pairs);
  }
  cache.set(key, value);
  return this;
}
Stack2.prototype.clear = stackClear2;
Stack2.prototype.delete = stackDelete2;
Stack2.prototype.get = stackGet2;
Stack2.prototype.has = stackHas2;
Stack2.prototype.set = stackSet2;
function assocIndexOf2(array, key) {
  var length = array.length;
  while (length--) {
    if (eq2(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseGetTag2(value) {
  return objectToString2.call(value);
}
function baseIsNative2(value) {
  if (!isObject4(value) || isMasked2(value)) {
    return false;
  }
  var pattern = isFunction3(value) || isHostObject2(value) ? reIsNative2 : reIsHostCtor2;
  return pattern.test(toSource2(value));
}
function getMapData2(map, key) {
  var data = map.__data__;
  return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative2(object, key) {
  var value = getValue2(object, key);
  return baseIsNative2(value) ? value : void 0;
}
var getSymbols2 = nativeGetSymbols2 ? overArg2(nativeGetSymbols2, Object) : stubArray2;
var getTag2 = baseGetTag2;
if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map3 && getTag2(new Map3()) != mapTag2 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
  getTag2 = function(value) {
    var result = objectToString2.call(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString2:
          return dataViewTag2;
        case mapCtorString2:
          return mapTag2;
        case promiseCtorString2:
          return promiseTag2;
        case setCtorString2:
          return setTag2;
        case weakMapCtorString2:
          return weakMapTag2;
      }
    }
    return result;
  };
}
function isKeyable2(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked2(func) {
  return !!maskSrcKey2 && maskSrcKey2 in func;
}
function toSource2(func) {
  if (func != null) {
    try {
      return funcToString2.call(func);
    } catch (e) {
    }
    try {
      return `${func}`;
    } catch (e) {
    }
  }
  return "";
}
function eq2(value, other) {
  return value === other || value !== value && other !== other;
}
var isArray2 = Array.isArray;
function isFunction3(value) {
  var tag = isObject4(value) ? objectToString2.call(value) : "";
  return tag == funcTag2 || tag == genTag2;
}
function isObject4(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function stubArray2() {
  return [];
}

// node_modules/@cloudinary/url-gen/instance/Cloudinary.js
var Cloudinary = class {
  constructor(cloudinaryConfig) {
    if (cloudinaryConfig) {
      this.cloudinaryConfig = cloudinaryConfig;
    }
  }
  image(publicID) {
    return new CloudinaryImage(publicID, this.cloudinaryConfig.cloud, this.cloudinaryConfig.url);
  }
  video(publicID) {
    return new CloudinaryVideo(publicID, this.cloudinaryConfig.cloud, this.cloudinaryConfig.url);
  }
  setConfig(cloudinaryConfig) {
    this.cloudinaryConfig = cloudinaryConfig;
    return this;
  }
  getConfig() {
    return this.cloudinaryConfig;
  }
  extendConfig() {
  }
};

// node_modules/@cloudinary/url-gen/backwards/consts.js
var NUMBER_PATTERN2 = "([0-9]*)\\.([0-9]+)|([0-9]+)";
var OFFSET_ANY_PATTERN2 = `(${NUMBER_PATTERN2})([%pP])?`;
var RANGE_VALUE_RE2 = RegExp(`^${OFFSET_ANY_PATTERN2}$`);
var OFFSET_ANY_PATTERN_RE2 = RegExp(`(${OFFSET_ANY_PATTERN2})\\.\\.(${OFFSET_ANY_PATTERN2})`);

// node_modules/@cloudinary/url-gen/backwards/utils/snakeCase.js
var snakeCase2 = (str) => str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);

// node_modules/@cloudinary/url-gen/backwards/configuration.js
var DEFAULT_CONFIGURATION_PARAMS2 = {
  responsive_class: "cld-responsive",
  responsive_use_breakpoints: true,
  round_dpr: true,
  secure: (typeof window !== "undefined" && window !== null ? window.location ? window.location.protocol : void 0 : void 0) === "https:"
};
var CONFIG_PARAMS2 = [
  "api_key",
  "api_secret",
  "callback",
  "cdn_subdomain",
  "cloud_name",
  "cname",
  "private_cdn",
  "protocol",
  "resource_type",
  "responsive",
  "responsive_class",
  "responsive_use_breakpoints",
  "responsive_width",
  "round_dpr",
  "secure",
  "secure_cdn_subdomain",
  "secure_distribution",
  "shorten",
  "type",
  "upload_preset",
  "url_suffix",
  "use_root_path",
  "version",
  "externalLibraries",
  "max_timeout_ms"
];

// node_modules/@cloudinary/url-gen/backwards/utils/legacyBaseUtil.js
var reWords2 = function() {
  var lower, upper;
  upper = "[A-Z]";
  lower = "[a-z]+";
  return RegExp(upper + "+(?=" + upper + lower + ")|" + upper + "?" + lower + "|" + upper + "+|[0-9]+", "g");
}();

// node_modules/@cloudinary/url-gen/backwards/transformation.js
var number_pattern2 = "([0-9]*)\\.([0-9]+)|([0-9]+)";
var offset_any_pattern2 = "(" + number_pattern2 + ")([%pP])?";
var methods2 = [
  "angle",
  "audioCodec",
  "audioFrequency",
  "aspectRatio",
  "background",
  "bitRate",
  "border",
  "color",
  "colorSpace",
  "crop",
  "customFunction",
  "customPreFunction",
  "defaultImage",
  "delay",
  "density",
  "duration",
  "dpr",
  "effect",
  "else",
  "endIf",
  "endOffset",
  "fallbackContent",
  "fetchFormat",
  "format",
  "flags",
  "gravity",
  "fps",
  "height",
  "htmlHeight",
  "htmlWidth",
  "if",
  "keyframeInterval",
  "ocr",
  "offset",
  "opacity",
  "overlay",
  "page",
  "poster",
  "prefix",
  "quality",
  "radius",
  "rawTransformation",
  "size",
  "sourceTypes",
  "sourceTransformation",
  "startOffset",
  "streamingProfile",
  "transformation",
  "underlay",
  "variable",
  "variables",
  "videoCodec",
  "videoSampling",
  "width",
  "x",
  "y",
  "zoom"
];
var PARAM_NAMES2 = methods2.map(snakeCase2).concat(CONFIG_PARAMS2);

// node_modules/@cloudinary-util/url-loader/dist/index.mjs
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var cropping_exports = {};
__export(cropping_exports, {
  assetTypes: () => assetTypes,
  normalizeNumberParameter: () => normalizeNumberParameter,
  plugin: () => plugin,
  props: () => props
});
var cropsGravityAuto = ["crop", "fill", "lfill", "fill_pad", "thumb"];
var cropsWithZoom = ["crop", "thumb"];
var props = [
  "crop",
  "gravity",
  "zoom"
];
var assetTypes = ["image", "images", "video", "videos"];
function normalizeNumberParameter(param) {
  if (typeof param !== "string")
    return param;
  return parseInt(param);
}
function plugin(props15) {
  const { cldAsset, options } = props15;
  const {
    width: defaultWidth,
    height: defaultHeight,
    widthResize: defaultWidthResize,
    crop: crop2 = "limit"
  } = options;
  const overrides = {
    width: void 0
  };
  let height = normalizeNumberParameter(defaultHeight);
  let width = normalizeNumberParameter(defaultWidth);
  let widthResize = normalizeNumberParameter(defaultWidthResize);
  let transformationString = "";
  if (width) {
    transformationString = `c_${crop2},w_${width}`;
  }
  if (!options.gravity && cropsGravityAuto.includes(crop2)) {
    options.gravity = "auto";
  }
  if (!["limit"].includes(crop2)) {
    transformationString = `${transformationString},h_${height}`;
  }
  if (options.gravity) {
    if (options.gravity === "auto" && !cropsGravityAuto.includes(crop2)) {
      console.warn(`Auto gravity can only be used with crop modes: ${cropsGravityAuto.join(", ")}. Not applying gravity.`);
    } else {
      transformationString = `${transformationString},g_${options.gravity}`;
    }
  }
  if (options.zoom) {
    if (options.zoom === "auto" && !cropsWithZoom.includes(crop2)) {
      console.warn(`Zoom can only be used with crop modes: ${cropsWithZoom.join(", ")}. Not applying zoom.`);
    } else {
      transformationString = `${transformationString},z_${options.zoom}`;
    }
  }
  cldAsset.effect(transformationString);
  if (width && widthResize && widthResize < width) {
    overrides.width = widthResize;
  }
  return {
    options: overrides
  };
}
var effects_exports = {};
__export(effects_exports, {
  assetTypes: () => assetTypes2,
  plugin: () => plugin2,
  props: () => props2
});
var convertersColors = [
  {
    test: testColorIsHex,
    convert: convertColorHexToRgb
  }
];
var primary = {
  aspectRatio: {
    qualifier: "ar"
  },
  crop: {
    qualifier: "c"
  },
  gravity: {
    qualifier: "g"
  },
  height: {
    qualifier: "h"
  },
  width: {
    qualifier: "w"
  }
};
var position = {
  angle: {
    qualifier: "a"
  },
  gravity: {
    qualifier: "g"
  },
  x: {
    qualifier: "x"
  },
  y: {
    qualifier: "y"
  }
};
var text2 = {
  alignment: {
    qualifier: false,
    order: 6
  },
  antialias: {
    qualifier: "antialias"
  },
  border: {
    qualifier: "bo",
    location: "primary"
  },
  color: {
    qualifier: "co",
    location: "primary",
    converters: convertersColors
  },
  fontFamily: {
    qualifier: false,
    order: 1
  },
  fontSize: {
    qualifier: false,
    order: 2
  },
  fontStyle: {
    qualifier: false,
    order: 4
  },
  fontWeight: {
    qualifier: false,
    order: 3
  },
  hinting: {
    qualifier: "hinting"
  },
  letterSpacing: {
    qualifier: "letter_spacing"
  },
  lineSpacing: {
    qualifier: "line_spacing"
  },
  stroke: {
    qualifier: "self",
    order: 7
  },
  textDecoration: {
    qualifier: false,
    order: 5
  }
};
var effects = {
  art: {
    prefix: "e",
    qualifier: "art"
  },
  autoBrightness: {
    prefix: "e",
    qualifier: "auto_brightness"
  },
  autoColor: {
    prefix: "e",
    qualifier: "auto_color"
  },
  autoContrast: {
    prefix: "e",
    qualifier: "auto_contrast"
  },
  assistColorblind: {
    prefix: "e",
    qualifier: "assist_colorblind"
  },
  background: {
    qualifier: "b"
  },
  blackwhite: {
    prefix: "e",
    qualifier: "blackwhite"
  },
  blur: {
    prefix: "e",
    qualifier: "blur"
  },
  blurFaces: {
    prefix: "e",
    qualifier: "blur_faces"
  },
  blurRegion: {
    prefix: "e",
    qualifier: "blur_region"
  },
  border: {
    qualifier: "bo"
  },
  brightness: {
    prefix: "e",
    qualifier: "brightness"
  },
  brightnessHSB: {
    prefix: "e",
    qualifier: "brightness_hsb"
  },
  cartoonify: {
    prefix: "e",
    qualifier: "cartoonify"
  },
  color: {
    qualifier: "co",
    converters: convertersColors
  },
  colorize: {
    prefix: "e",
    qualifier: "colorize"
  },
  contrast: {
    prefix: "e",
    qualifier: "contrast"
  },
  distort: {
    prefix: "e",
    qualifier: "distort"
  },
  fillLight: {
    prefix: "e",
    qualifier: "fill_light"
  },
  gamma: {
    prefix: "e",
    qualifier: "gamma"
  },
  gradientFade: {
    prefix: "e",
    qualifier: "gradient_fade"
  },
  grayscale: {
    prefix: "e",
    qualifier: "grayscale"
  },
  improve: {
    prefix: "e",
    qualifier: "improve"
  },
  multiply: {
    prefix: "e",
    qualifier: "multiply"
  },
  negate: {
    prefix: "e",
    qualifier: "negate"
  },
  oilPaint: {
    prefix: "e",
    qualifier: "oil_paint"
  },
  opacity: {
    qualifier: "o"
  },
  outline: {
    prefix: "e",
    qualifier: "outline"
  },
  overlay: {
    prefix: "e",
    qualifier: "overlay"
  },
  pixelate: {
    prefix: "e",
    qualifier: "pixelate"
  },
  pixelateFaces: {
    prefix: "e",
    qualifier: "pixelate_faces"
  },
  pixelateRegion: {
    prefix: "e",
    qualifier: "pixelate_region"
  },
  radius: {
    qualifier: "r"
  },
  redeye: {
    prefix: "e",
    qualifier: "redeye"
  },
  replaceColor: {
    prefix: "e",
    qualifier: "replace_color"
  },
  saturation: {
    prefix: "e",
    qualifier: "saturation"
  },
  screen: {
    prefix: "e",
    qualifier: "screen"
  },
  sepia: {
    prefix: "e",
    qualifier: "sepia"
  },
  shadow: {
    prefix: "e",
    qualifier: "shadow"
  },
  sharpen: {
    prefix: "e",
    qualifier: "sharpen"
  },
  shear: {
    prefix: "e",
    qualifier: "shear"
  },
  simulateColorblind: {
    prefix: "e",
    qualifier: "simulate_colorblind"
  },
  tint: {
    prefix: "e",
    qualifier: "tint"
  },
  trim: {
    prefix: "e",
    qualifier: "trim"
  },
  unsharpMask: {
    prefix: "e",
    qualifier: "unsharp_mask"
  },
  vectorize: {
    prefix: "e",
    qualifier: "vectorize"
  },
  vibrance: {
    prefix: "e",
    qualifier: "vibrance"
  },
  vignette: {
    prefix: "e",
    qualifier: "vignette"
  }
};
var flags = {
  animated: {
    prefix: "fl",
    qualifier: "animated"
  },
  anyFormat: {
    prefix: "fl",
    qualifier: "any_format"
  },
  apng: {
    prefix: "fl",
    qualifier: "apng"
  },
  attachment: {
    prefix: "fl",
    qualifier: "attachment"
  },
  awebp: {
    prefix: "fl",
    qualifier: "awebp"
  },
  clip: {
    prefix: "fl",
    qualifier: "clip"
  },
  clipEvenodd: {
    prefix: "fl",
    qualifier: "clip_evenodd"
  },
  cutter: {
    prefix: "fl",
    qualifier: "cutter"
  },
  draco: {
    prefix: "fl",
    qualifier: "draco"
  },
  forceIcc: {
    prefix: "fl",
    qualifier: "force_icc"
  },
  forceStrip: {
    prefix: "fl",
    qualifier: "force_strip"
  },
  getinfo: {
    prefix: "fl",
    qualifier: "getinfo"
  },
  group4: {
    prefix: "fl",
    qualifier: "group4"
  },
  hlsv3: {
    prefix: "fl",
    qualifier: "hlsv3"
  },
  ignoreAspectRatio: {
    prefix: "fl",
    qualifier: "ignore_aspect_ratio"
  },
  ignoreMaskChannels: {
    prefix: "fl",
    qualifier: "ignore_mask_channels"
  },
  immutableCache: {
    prefix: "fl",
    qualifier: "immutable_cache"
  },
  keepAttribution: {
    prefix: "fl",
    qualifier: "keep_attribution"
  },
  keepDar: {
    prefix: "fl",
    qualifier: "keep_dar"
  },
  keepIptc: {
    prefix: "fl",
    qualifier: "keep_iptc"
  },
  layerApply: {
    prefix: "fl",
    qualifier: "layer_apply"
  },
  lossy: {
    prefix: "fl",
    qualifier: "lossy"
  },
  mono: {
    prefix: "fl",
    qualifier: "mono"
  },
  noOverflow: {
    prefix: "fl",
    qualifier: "no_overflow"
  },
  noStream: {
    prefix: "fl",
    qualifier: "no_stream"
  },
  png8: {
    prefix: "fl",
    qualifier: "png8"
  },
  png24: {
    prefix: "fl",
    qualifier: "png24"
  },
  png32: {
    prefix: "fl",
    qualifier: "png32"
  },
  preserveTransparency: {
    prefix: "fl",
    qualifier: "preserve_transparency"
  },
  progressive: {
    prefix: "fl",
    qualifier: "progressive"
  },
  rasterize: {
    prefix: "fl",
    qualifier: "rasterize"
  },
  regionRelative: {
    prefix: "fl",
    qualifier: "region_relative"
  },
  relative: {
    prefix: "fl",
    qualifier: "relative",
    location: "primary"
  },
  replaceImage: {
    prefix: "fl",
    qualifier: "replace_image"
  },
  sanitize: {
    prefix: "fl",
    qualifier: "sanitize"
  },
  splice: {
    prefix: "fl",
    qualifier: "splice"
  },
  streamingAttachment: {
    prefix: "fl",
    qualifier: "streaming_attachment"
  },
  stripProfile: {
    prefix: "fl",
    qualifier: "strip_profile"
  },
  textDisallowOverflow: {
    prefix: "fl",
    qualifier: "text_disallow_overflow"
  },
  textNoTrim: {
    prefix: "fl",
    qualifier: "text_no_trim"
  },
  tif8Lzw: {
    prefix: "fl",
    qualifier: "tif8_lzw"
  },
  tiled: {
    prefix: "fl",
    qualifier: "tiled"
  },
  truncateTs: {
    prefix: "fl",
    qualifier: "truncate_ts"
  },
  waveform: {
    prefix: "fl",
    qualifier: "waveform"
  }
};
var video2 = {
  streamingProfile: {
    qualifier: "sp",
    location: "primary"
  }
};
function constructTransformation({ prefix, qualifier, value, converters }) {
  let transformation = "";
  if (prefix) {
    transformation = `${prefix}_`;
  }
  let transformationValue = value;
  converters == null ? void 0 : converters.forEach(({ test, convert }) => {
    if (!test(transformationValue))
      return;
    transformationValue = convert(transformationValue);
  });
  if (transformationValue === true || transformationValue === "true") {
    return `${transformation}${qualifier}`;
  }
  if (typeof transformationValue === "string" || typeof transformationValue === "number") {
    if (prefix) {
      return `${transformation}${qualifier}:${transformationValue}`;
    } else {
      return `${qualifier}_${transformationValue}`;
    }
  }
}
var props2 = [...Object.keys(effects), "effects"];
var assetTypes2 = ["image", "images", "video", "videos"];
function plugin2(props15) {
  const { cldAsset, options } = props15;
  const transformationStrings = constructTransformationString({
    effects,
    options
  });
  transformationStrings.filter((t) => !!t).forEach((transformation) => cldAsset.effect(transformation));
  ;
  if (Array.isArray(options == null ? void 0 : options.effects)) {
    options == null ? void 0 : options.effects.forEach((effectsSet) => {
      const transformationString = constructTransformationString({
        effects,
        options: effectsSet
      }).filter((t) => !!t).join(",");
      cldAsset.effect(transformationString);
    });
  }
  function constructTransformationString({ effects: effects2, options: options2 }) {
    return Object.keys(effects2).map((key) => {
      const { prefix, qualifier, converters } = effects2[key];
      return constructTransformation({
        qualifier,
        prefix,
        value: options2 == null ? void 0 : options2[key],
        converters
      });
    });
  }
  return {};
}
var flags_exports = {};
__export(flags_exports, {
  assetTypes: () => assetTypes3,
  plugin: () => plugin3,
  props: () => props3
});
var props3 = ["flags"];
var assetTypes3 = ["image", "images", "video", "videos"];
var supportedFlags = Object.entries(flags).map(([_, { qualifier }]) => qualifier);
function plugin3(props15) {
  const { cldAsset, options } = props15;
  const { flags: flags2 = [] } = options;
  if (Array.isArray(flags2) && flags2.length > 0) {
    flags2.forEach((flag) => {
      if (!supportedFlags.includes(flag))
        return;
      cldAsset.addFlag(flag);
    });
  } else if (typeof flags2 === "object") {
    Object.entries(flags2).forEach(([qualifier, value]) => {
      if (!supportedFlags.includes(qualifier))
        return;
      cldAsset.addTransformation(`fl_${qualifier}:${value}`);
    });
  }
  return {};
}
var fill_background_exports = {};
__export(fill_background_exports, {
  assetTypes: () => assetTypes4,
  plugin: () => plugin4,
  props: () => props4
});
var props4 = ["fillBackground"];
var assetTypes4 = ["image", "images"];
var defaultCrop = "pad";
function plugin4(props15) {
  const { cldAsset, options } = props15;
  const { fillBackground } = options;
  if (fillBackground === true) {
    const properties = [
      "b_gen_fill",
      `ar_${options.width}:${options.height}`,
      `w_${options.width}`,
      `c_${defaultCrop}`
    ];
    cldAsset.addTransformation(properties.join(","));
  } else if (typeof fillBackground === "object") {
    const { crop: crop2 = defaultCrop, gravity, prompt } = fillBackground;
    const properties = [
      `ar_${options.width}:${options.height}`,
      `w_${options.width}`,
      `c_${crop2}`
    ];
    if (typeof prompt === "string") {
      properties.unshift(`b_gen_fill:${prompt}`);
    } else {
      properties.unshift(`b_gen_fill`);
    }
    if (typeof gravity === "string") {
      properties.push(`g_${gravity}`);
    }
    cldAsset.addTransformation(properties.join(","));
  }
  return {};
}
var sanitize_exports = {};
__export(sanitize_exports, {
  assetTypes: () => assetTypes5,
  plugin: () => plugin5,
  props: () => props5
});
var props5 = ["sanitize"];
var assetTypes5 = ["image", "images"];
function plugin5(props15) {
  const { cldAsset, options } = props15;
  const { sanitize = true } = options;
  const shouldApplySanitizer = sanitize && (options.format === "svg" || cldAsset.publicID.endsWith(".svg"));
  if (shouldApplySanitizer) {
    cldAsset.effect("fl_sanitize");
  }
  return {};
}
var overlays_exports = {};
__export(overlays_exports, {
  DEFAULT_TEXT_OPTIONS: () => DEFAULT_TEXT_OPTIONS,
  assetTypes: () => assetTypes6,
  plugin: () => plugin6,
  props: () => props6
});
var props6 = ["text", "overlays"];
var assetTypes6 = ["image", "images", "video", "videos"];
var DEFAULT_TEXT_OPTIONS = {
  color: "black",
  fontFamily: "Arial",
  fontSize: 200,
  fontWeight: "bold"
};
function plugin6(props15) {
  const { cldAsset, options } = props15;
  const { text: text22, overlays = [] } = options;
  const type = "overlay";
  const typeQualifier = "l";
  if (Array.isArray(overlays)) {
    overlays.forEach(applyOverlay);
  }
  if (typeof text22 === "string") {
    applyOverlay({
      text: {
        ...DEFAULT_TEXT_OPTIONS,
        text: text22
      }
    });
  } else if (typeof text22 === "object") {
    applyOverlay({
      text: {
        ...DEFAULT_TEXT_OPTIONS,
        ...text22
      }
    });
  }
  function applyOverlay({ publicId, url, position: position2, text: text3, effects: layerEffects = [], appliedEffects = [], ...options2 }) {
    var _a;
    const hasPublicId = typeof publicId === "string";
    const hasUrl = typeof url === "string";
    const hasText = typeof text3 === "object" || typeof text3 === "string";
    const hasPosition = typeof position2 === "object";
    if (!hasPublicId && !hasUrl && !hasText) {
      console.warn(`An ${type} is missing Public ID, URL, or Text`);
      return;
    }
    let layerTransformation;
    if (hasText) {
      layerTransformation = `${typeQualifier}_text`;
    } else if (hasPublicId) {
      layerTransformation = `${typeQualifier}_${publicId.replace(/\//g, ":")}`;
    } else if (hasUrl) {
      layerTransformation = `${typeQualifier}_fetch:${encodeBase64(url)}`;
    }
    const primary2 = [];
    const applied = [];
    Object.keys(options2).forEach((key) => {
      if (!objectHasKey(primary, key))
        return;
      const { qualifier, converters } = primary[key];
      const transformation = constructTransformation({
        qualifier,
        value: options2[key],
        converters
      });
      if (transformation) {
        primary2.push(transformation);
      }
    });
    layerEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        const { qualifier, prefix, converters } = primary[key] || effects[key] || {};
        const transformation = constructTransformation({
          qualifier,
          prefix,
          value: effect[key],
          converters
        });
        if (transformation) {
          primary2.push(transformation);
        }
      });
    });
    appliedEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        const { qualifier, prefix, converters } = primary[key] || effects[key] || {};
        const transformation = constructTransformation({
          qualifier,
          prefix,
          value: effect[key],
          converters
        });
        if (transformation) {
          applied.push(transformation);
        }
      });
    });
    if (hasText) {
      if (typeof text3 === "string") {
        text3 = {
          ...DEFAULT_TEXT_OPTIONS,
          text: text3
        };
      }
      const textTransformations = [];
      if (typeof text3 === "object") {
        const textOptions = Object.keys(text3).filter((key) => objectHasKey(text2, key)).map((key) => {
          const value = text3 && objectHasKey(text3, key) && text3[key];
          return {
            ...text2[key],
            key,
            value,
            order: text2[key].order || 99
          };
        });
        const sortedTextOptions = sortByKey(textOptions, "order");
        for (const textOption of sortedTextOptions) {
          const { key, value, qualifier, location, converters } = textOption;
          let textValue = value;
          converters == null ? void 0 : converters.forEach(({ test, convert }) => {
            if (!test(value))
              return;
            textValue = convert(value);
          });
          if (location === "primary") {
            primary2.push(`${qualifier}_${textValue}`);
          } else if (qualifier === "self") {
            textTransformations.push(key);
          } else if (qualifier) {
            textTransformations.push(`${qualifier}_${textValue}`);
          } else {
            textTransformations.push(textValue);
          }
        }
      }
      const specialCharacters = {
        ".": "%2E",
        ",": "%2C",
        "/": "%2F"
      };
      let layerText = (text3 == null ? void 0 : text3.text) || "";
      if (typeof layerText === "string") {
        (_a = Object.keys(specialCharacters)) == null ? void 0 : _a.forEach((character) => {
          layerText = layerText == null ? void 0 : layerText.replace(character, specialCharacters[character]);
        });
      }
      layerTransformation = `${layerTransformation}:${textTransformations.join("_")}:${layerText}`;
    }
    if (hasPosition) {
      Object.keys(position2).forEach((key) => {
        if (!objectHasKey(position, key))
          return;
        const { qualifier, converters } = position[key];
        const transformation = constructTransformation({
          qualifier,
          value: position2[key],
          converters
        });
        if (transformation) {
          applied.push(transformation);
        }
      });
    }
    if (primary2.length > 0) {
      layerTransformation = `${layerTransformation},${primary2.join(",")}`;
    }
    layerTransformation = `${layerTransformation}/fl_layer_apply,fl_no_overflow`;
    if (applied.length > 0) {
      layerTransformation = `${layerTransformation},${applied.join(",")}`;
    }
    cldAsset.addTransformation(layerTransformation);
  }
  return {};
}
var named_transformations_exports = {};
__export(named_transformations_exports, {
  assetTypes: () => assetTypes7,
  plugin: () => plugin7,
  props: () => props7
});
var props7 = ["transformations"];
var assetTypes7 = ["image", "images", "video", "videos"];
function plugin7(props15) {
  const { cldAsset, options } = props15;
  let { transformations = [] } = options;
  if (!Array.isArray(transformations)) {
    transformations = [transformations];
  }
  transformations.forEach((transformation) => {
    cldAsset.addTransformation(`t_${transformation}`);
  });
  return {};
}
var raw_transformations_exports = {};
__export(raw_transformations_exports, {
  assetTypes: () => assetTypes8,
  plugin: () => plugin8,
  props: () => props8
});
var props8 = ["rawTransformations"];
var assetTypes8 = ["image", "images", "video", "videos"];
function plugin8(props15) {
  const { cldAsset, options } = props15;
  const { rawTransformations = [] } = options;
  rawTransformations.forEach((transformation) => {
    cldAsset.addTransformation(transformation);
  });
  return {};
}
var remove_background_exports = {};
__export(remove_background_exports, {
  assetTypes: () => assetTypes9,
  plugin: () => plugin9,
  props: () => props9
});
var props9 = ["removeBackground"];
var assetTypes9 = ["image", "images"];
function plugin9(props15) {
  const { cldAsset, options } = props15;
  const { removeBackground: removeBackground2 = false } = options;
  if (removeBackground2) {
    cldAsset.effect("e_background_removal");
  }
  return {};
}
var seo_exports = {};
__export(seo_exports, {
  assetTypes: () => assetTypes10,
  plugin: () => plugin10,
  props: () => props10
});
var props10 = ["seoSuffix"];
var assetTypes10 = ["image", "images", "video", "videos"];
function plugin10(props15) {
  const { cldAsset, options } = props15;
  const { seoSuffix } = options;
  if (typeof seoSuffix === "string") {
    if (options.deliveryType === "fetch") {
      console.warn("SEO suffix is not supported with a delivery type of fetch");
    } else {
      cldAsset.setSuffix(seoSuffix);
    }
  }
  return {};
}
var underlays_exports = {};
__export(underlays_exports, {
  assetTypes: () => assetTypes11,
  plugin: () => plugin11,
  props: () => props11
});
var props11 = ["underlay", "underlays"];
var assetTypes11 = ["image", "images", "video", "videos"];
function plugin11(props15) {
  const { cldAsset, options } = props15;
  const { underlay, underlays = [] } = options;
  const typeQualifier = "u";
  if (Array.isArray(underlays)) {
    underlays.forEach(applyUnderlay);
  }
  if (typeof underlay === "string") {
    const underlayOptions = {
      publicId: underlay,
      crop: "fill",
      width: "1.0",
      height: "1.0",
      flags: ["relative"]
    };
    applyUnderlay(underlayOptions);
  }
  function applyUnderlay({ publicId, type, position: position2, effects: layerEffects = [], flags: flags2 = [], ...options2 }) {
    const hasPublicId = typeof publicId === "string";
    const hasPosition = typeof position2 === "object";
    if (!hasPublicId) {
      console.warn(`An ${type} is missing a Public ID`);
      return;
    }
    let layerTransformation = `${typeQualifier}_${publicId.replace(/\//g, ":")}`;
    const primary2 = [];
    const applied = [];
    Object.keys(options2).forEach((key) => {
      if (!objectHasKey(primary, key))
        return;
      const { qualifier } = primary[key];
      primary2.push(`${qualifier}_${options2[key]}`);
    });
    layerEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        if (!objectHasKey(primary, key))
          return;
        const { qualifier } = primary[key];
        primary2.push(`${qualifier}_${effect[key]}`);
      });
    });
    if (hasPosition) {
      Object.keys(position2).forEach((key) => {
        if (!objectHasKey(position, key))
          return;
        const { qualifier } = position[key];
        applied.push(`${qualifier}_${position2[key]}`);
      });
    }
    flags2.forEach((key) => {
      if (!objectHasKey(flags, key))
        return;
      const { qualifier, prefix } = flags[key];
      primary2.push(`${prefix}_${qualifier}`);
    });
    layerTransformation = `${layerTransformation},${primary2.join(",")}`;
    layerTransformation = `${layerTransformation}/fl_layer_apply,fl_no_overflow`;
    if (applied.length > 0) {
      layerTransformation = `${layerTransformation},${applied.join(",")}`;
    }
    cldAsset.addTransformation(layerTransformation);
  }
  return {};
}
var version_exports = {};
__export(version_exports, {
  assetTypes: () => assetTypes12,
  plugin: () => plugin12,
  props: () => props12
});
var props12 = ["version"];
var assetTypes12 = ["image", "images", "video", "videos"];
function plugin12(props15) {
  const { cldAsset, options } = props15;
  const { version } = options;
  if (typeof version === "string" || typeof version === "number") {
    cldAsset.setVersion(`${version}`.replace("v", ""));
  }
  return {};
}
var video_exports = {};
__export(video_exports, {
  assetTypes: () => assetTypes13,
  plugin: () => plugin13,
  props: () => props13
});
var props13 = [...Object.keys(video2)];
var assetTypes13 = ["video", "videos"];
function plugin13(props15) {
  const { cldAsset, options } = props15;
  Object.keys(options).forEach((key) => {
    if (!objectHasKey(video2, key))
      return;
    const { prefix, qualifier, converters } = video2[key];
    const transformation = constructTransformation({
      prefix,
      qualifier,
      value: options[key],
      converters
    });
    cldAsset.addTransformation(transformation);
  });
  return {};
}
var zoompan_exports = {};
__export(zoompan_exports, {
  assetTypes: () => assetTypes14,
  plugin: () => plugin14,
  props: () => props14
});
var props14 = ["zoompan"];
var assetTypes14 = ["image", "images"];
function plugin14(props15) {
  const { cldAsset, options } = props15;
  const { zoompan = false } = options;
  const overrides = {
    format: void 0
  };
  if (zoompan === true) {
    cldAsset.effect("e_zoompan");
  } else if (typeof zoompan === "string") {
    if (zoompan === "loop") {
      cldAsset.effect("e_zoompan");
      cldAsset.effect("e_loop");
    } else {
      cldAsset.effect(`e_zoompan:${zoompan}`);
    }
  } else if (typeof zoompan === "object") {
    let zoompanEffect = "e_zoompan";
    if (typeof zoompan.options === "string") {
      zoompanEffect = `${zoompanEffect}${zoompan.options}`;
    }
    cldAsset.effect(zoompanEffect);
    let loopEffect;
    if (zoompan.loop === true) {
      loopEffect = "e_loop";
    } else if (typeof zoompan.loop === "string") {
      loopEffect = `e_loop${zoompan.loop}`;
    }
    if (loopEffect) {
      cldAsset.effect(loopEffect);
    }
  }
  if (zoompan !== false) {
    overrides.format = "gif";
  }
  return {
    options: overrides
  };
}
var transformationPlugins = [
  remove_background_exports,
  raw_transformations_exports,
  cropping_exports,
  effects_exports,
  fill_background_exports,
  flags_exports,
  overlays_exports,
  sanitize_exports,
  named_transformations_exports,
  seo_exports,
  underlays_exports,
  version_exports,
  video_exports,
  zoompan_exports
];
function constructCloudinaryUrl({ options, config, analytics }) {
  const cld = new Cloudinary(config);
  if (typeof (options == null ? void 0 : options.src) !== "string") {
    throw Error(`Failed to construct Cloudinary URL: Missing source (src) in options`);
  }
  if (!(options == null ? void 0 : options.assetType)) {
    options.assetType = "image";
  }
  const propsCheck = [];
  transformationPlugins.forEach(({ props: props15 = [] }) => {
    props15.forEach((prop) => {
      if (propsCheck.includes(prop)) {
        throw new Error(`Option ${prop} already exists!`);
      }
      propsCheck.push(prop);
    });
  });
  const parsedOptions = {
    seoSuffix: void 0,
    version: void 0
  };
  let publicId;
  if (typeof options.src === "string" && /^https?:\/\//.test(options.src)) {
    try {
      const parts = parseUrl(options.src);
      publicId = parts == null ? void 0 : parts.publicId;
      parsedOptions.seoSuffix = parts == null ? void 0 : parts.seoSuffix;
      parsedOptions.version = parts == null ? void 0 : parts.version;
    } catch (e) {
    }
  }
  if (!publicId) {
    publicId = options.src;
  }
  Object.keys(parsedOptions).forEach((key) => {
    if (objectHasKey(options, key))
      return;
    options[key] = parsedOptions[key];
  });
  let cldAsset = void 0;
  if (["image", "images"].includes(options.assetType)) {
    cldAsset = cld.image(publicId);
  } else if (["video", "videos"].includes(options.assetType)) {
    cldAsset = cld.video(publicId);
  }
  if (typeof cldAsset === "undefined") {
    throw new Error("Invalid asset type.");
  }
  transformationPlugins.forEach(({ plugin: plugin15, assetTypes: assetTypes15, props: props15 }) => {
    const supportedAssetType = typeof (options == null ? void 0 : options.assetType) !== "undefined" && assetTypes15.includes(options == null ? void 0 : options.assetType);
    if (!supportedAssetType) {
      const optionsKeys = Object.keys(options);
      const attemptedUse = props15.map((prop) => optionsKeys.includes(prop)).filter((isUsed) => !!isUsed).length > 0;
      if (attemptedUse) {
        console.warn(`One of the following props [${props15.join(", ")}] was used with an unsupported asset type [${options == null ? void 0 : options.assetType}]`);
      }
      return;
    }
    const results = plugin15({
      cldAsset,
      options
    });
    const { options: pluginOptions } = results || { options: void 0 };
    if ((pluginOptions == null ? void 0 : pluginOptions.format) && options) {
      options.format = pluginOptions.format;
    }
    if ((pluginOptions == null ? void 0 : pluginOptions.width) && options) {
      options.resize = {
        width: pluginOptions == null ? void 0 : pluginOptions.width
      };
    }
  });
  if (options == null ? void 0 : options.resize) {
    const { width, crop: crop2 = "scale" } = options.resize;
    cldAsset.effect(`c_${crop2},w_${width}`);
  }
  cldAsset.setDeliveryType((options == null ? void 0 : options.deliveryType) || "upload");
  if ((options == null ? void 0 : options.format) !== "default") {
    cldAsset.format((options == null ? void 0 : options.format) || "auto");
  }
  if ((options == null ? void 0 : options.quality) !== "default") {
    cldAsset.quality((options == null ? void 0 : options.quality) || "auto");
  }
  return cldAsset.toURL({
    trackedAnalytics: analytics
  });
}

export {
  primary,
  position,
  text2 as text,
  effects,
  transformationPlugins,
  constructCloudinaryUrl
};
//# sourceMappingURL=chunk-OT2LBKF6.js.map
