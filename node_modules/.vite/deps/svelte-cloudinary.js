import "./chunk-DKNDEOWF.js";
import {
  constructCloudinaryUrl,
  transformationPlugins
} from "./chunk-OT2LBKF6.js";
import {
  getTransformations
} from "./chunk-HQRXJUTC.js";
import {
  transformProps
} from "./chunk-RA5CW2UK.js";
import {
  require_dist
} from "./chunk-BXAEMNMH.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  check_outros,
  claim_component,
  claim_element,
  create_component,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_spread_object,
  get_spread_update,
  group_outros,
  head_selector,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  safe_not_equal,
  set_attributes,
  transition_in,
  transition_out,
  validate_slots
} from "./chunk-7HXGFHLI.js";
import "./chunk-5UFCALFR.js";
import {
  __toESM
} from "./chunk-TCQZMY3T.js";

// node_modules/@unpic/svelte/dist/image.svelte
var import_style_object_to_css_string = __toESM(require_dist());
var file = "node_modules/@unpic/svelte/dist/image.svelte";
function create_fragment(ctx) {
  let img;
  let img_levels = [
    { alt: (
      /*alt*/
      ctx[2]
    ) },
    { style: (
      /*style*/
      ctx[0]
    ) },
    /*transformedProps*/
    ctx[1]
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { alt: true, style: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file, 14, 0, 355);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*alt*/
        4 && { alt: (
          /*alt*/
          ctx2[2]
        ) },
        dirty & /*style*/
        1 && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty & /*transformedProps*/
        2 && /*transformedProps*/
        ctx2[1]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let parentStyle;
  let props;
  let alt;
  let styleObj;
  let transformedProps;
  let style;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({
    transformProps,
    styleToCss: import_style_object_to_css_string.default,
    parentStyle,
    styleObj,
    style,
    props,
    transformedProps,
    alt
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("parentStyle" in $$props)
      $$invalidate(3, parentStyle = $$new_props.parentStyle);
    if ("styleObj" in $$props)
      $$invalidate(4, styleObj = $$new_props.styleObj);
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("props" in $$props)
      $$invalidate(5, props = $$new_props.props);
    if ("transformedProps" in $$props)
      $$invalidate(1, transformedProps = $$new_props.transformedProps);
    if ("alt" in $$props)
      $$invalidate(2, alt = $$new_props.alt);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, { style: parentStyle, ...props } = $$props, parentStyle, ($$invalidate(5, props), $$invalidate(6, $$props)));
    if ($$self.$$.dirty & /*props*/
    32) {
      $:
        $$invalidate(2, { alt, style: styleObj, ...transformedProps } = transformProps({ ...props, style: {} }), alt, ($$invalidate(4, styleObj), $$invalidate(5, props), $$invalidate(6, $$props)), ($$invalidate(1, transformedProps), $$invalidate(5, props), $$invalidate(6, $$props)));
    }
    if ($$self.$$.dirty & /*styleObj, parentStyle*/
    24) {
      $:
        $$invalidate(0, style = [(0, import_style_object_to_css_string.default)(styleObj), parentStyle].filter(Boolean).join(";"));
    }
  };
  $$props = exclude_internal_props($$props);
  return [style, transformedProps, alt, parentStyle, styleObj, props];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment.name
    });
  }
};
var image_default = Image;

// node_modules/svelte/package.json
var package_default = {
  name: "svelte",
  version: "4.1.1",
  description: "Cybernetically enhanced web apps",
  type: "module",
  module: "src/runtime/index.js",
  main: "src/runtime/index.js",
  files: [
    "src",
    "!src/**/tsconfig.json",
    "types",
    "compiler.*",
    "register.js",
    "index.d.ts",
    "store.d.ts",
    "animate.d.ts",
    "transition.d.ts",
    "easing.d.ts",
    "motion.d.ts",
    "action.d.ts",
    "elements.d.ts",
    "README.md"
  ],
  exports: {
    "./package.json": "./package.json",
    ".": {
      types: "./types/index.d.ts",
      browser: {
        default: "./src/runtime/index.js"
      },
      default: "./src/runtime/ssr.js"
    },
    "./compiler": {
      types: "./types/index.d.ts",
      require: "./compiler.cjs",
      default: "./src/compiler/index.js"
    },
    "./action": {
      types: "./types/index.d.ts"
    },
    "./animate": {
      types: "./types/index.d.ts",
      default: "./src/runtime/animate/index.js"
    },
    "./easing": {
      types: "./types/index.d.ts",
      default: "./src/runtime/easing/index.js"
    },
    "./internal": {
      default: "./src/runtime/internal/index.js"
    },
    "./motion": {
      types: "./types/index.d.ts",
      default: "./src/runtime/motion/index.js"
    },
    "./store": {
      types: "./types/index.d.ts",
      default: "./src/runtime/store/index.js"
    },
    "./internal/disclose-version": {
      default: "./src/runtime/internal/disclose-version/index.js"
    },
    "./transition": {
      types: "./types/index.d.ts",
      default: "./src/runtime/transition/index.js"
    },
    "./elements": {
      types: "./elements.d.ts"
    }
  },
  engines: {
    node: ">=16"
  },
  types: "types/index.d.ts",
  repository: {
    type: "git",
    url: "https://github.com/sveltejs/svelte.git",
    directory: "packages/svelte"
  },
  keywords: [
    "UI",
    "framework",
    "templates",
    "templating"
  ],
  author: "Rich Harris",
  license: "MIT",
  bugs: {
    url: "https://github.com/sveltejs/svelte/issues"
  },
  homepage: "https://svelte.dev",
  dependencies: {
    "@ampproject/remapping": "^2.2.1",
    "@jridgewell/sourcemap-codec": "^1.4.15",
    "@jridgewell/trace-mapping": "^0.3.18",
    acorn: "^8.9.0",
    "aria-query": "^5.3.0",
    "axobject-query": "^3.2.1",
    "code-red": "^1.0.3",
    "css-tree": "^2.3.1",
    "estree-walker": "^3.0.3",
    "is-reference": "^3.0.1",
    "locate-character": "^3.0.0",
    "magic-string": "^0.30.0",
    periscopic: "^3.1.0"
  },
  devDependencies: {
    "@playwright/test": "^1.35.1",
    "@rollup/plugin-commonjs": "^24.1.0",
    "@rollup/plugin-json": "^6.0.0",
    "@rollup/plugin-node-resolve": "^15.1.0",
    "@sveltejs/eslint-config": "^6.0.4",
    "@types/aria-query": "^5.0.1",
    "@types/estree": "^1.0.1",
    "@types/node": "^14.18.51",
    agadoo: "^3.0.0",
    "dts-buddy": "^0.1.7",
    esbuild: "^0.18.11",
    "happy-dom": "^9.20.3",
    jsdom: "^21.1.2",
    kleur: "^4.1.5",
    rollup: "^3.26.2",
    "source-map": "^0.7.4",
    "tiny-glob": "^0.2.9",
    typescript: "^5.1.3",
    vitest: "^0.33.0"
  },
  scripts: {
    format: "prettier . --cache --plugin-search-dir=. --write",
    check: "tsc --noEmit",
    test: 'vitest run && echo "manually check that there are no type errors in test/types by opening the files in there"',
    build: "rollup -c && pnpm types",
    "generate:version": "node ./scripts/generate-version.js",
    dev: "rollup -cw",
    posttest: "agadoo src/internal/index.js",
    types: "node ./scripts/generate-dts.js",
    lint: 'prettier . --cache --plugin-search-dir=. --check && eslint "{src,test}/**/*.{ts,js}" --cache'
  }
};

// node_modules/svelte-cloudinary/dist/metadata.json
var metadata_default = { version: "1.0.3" };

// node_modules/svelte-cloudinary/dist/constants/analytics.js
var SVELTE_CLOUDINARY_ANALYTICS_ID = "E";
var SVELTE_CLOUDINARY_VERSION = metadata_default.version.split("-")[0];
var SVELTE_VERSION = `${package_default.version.split(".")[0]}.0.0`;

// node_modules/svelte-cloudinary/dist/helpers/getCldImageUrl.js
function getCldImageUrl(options, config, analytics) {
  return constructCloudinaryUrl({
    options,
    config: Object.assign({
      cloud: {
        cloudName: import.meta.env.VITE_PUBLIC_CLOUDINARY_CLOUD_NAME
      }
    }, config),
    analytics: Object.assign({
      sdkCode: SVELTE_CLOUDINARY_ANALYTICS_ID,
      sdkSemver: SVELTE_CLOUDINARY_VERSION,
      techVersion: SVELTE_VERSION,
      product: "B"
    }, analytics)
  });
}

// node_modules/svelte-cloudinary/dist/components/CldImage.svelte
function create_if_block(ctx) {
  let image;
  let current;
  const image_spread_levels = [
    /*imageProps*/
    ctx[0],
    { cdn: "cloudinary" },
    { transformer: (
      /*func*/
      ctx[7]
    ) }
  ];
  let image_props = {};
  for (let i = 0; i < image_spread_levels.length; i += 1) {
    image_props = assign(image_props, image_spread_levels[i]);
  }
  image = new image_default({ props: image_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(image.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(image.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(image, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const image_changes = dirty & /*imageProps, cldOptions, parseInt, config*/
      7 ? get_spread_update(image_spread_levels, [
        dirty & /*imageProps*/
        1 && get_spread_object(
          /*imageProps*/
          ctx2[0]
        ),
        image_spread_levels[1],
        { transformer: (
          /*func*/
          ctx2[7]
        ) }
      ]) : {};
      image.$set(image_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(image.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(image.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(image, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(46:0) {#if imageProps.src}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*imageProps*/
    ctx[0].src && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*imageProps*/
        ctx2[0].src
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*imageProps*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let alt;
  let src;
  let width;
  let height;
  let config;
  let imageProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CldImage", slots, []);
  const CLD_OPTIONS = ["config", "deliveryType", "preserveTransformations"];
  transformationPlugins.forEach(({ props = [] }) => {
    props.forEach((prop) => {
      if (CLD_OPTIONS.includes(prop)) {
        throw new Error(`Option ${prop} already exists!`);
      }
      CLD_OPTIONS.push(prop);
    });
  });
  const cldOptions = {};
  CLD_OPTIONS.forEach((key) => {
    if ($$props[key]) {
      $$invalidate(1, cldOptions[key] = $$props[key] || void 0, cldOptions);
    }
  });
  if ($$props.preserveTransformations) {
    try {
      const transformations = getTransformations(imageProps.src).map((t) => t.join(","));
      cldOptions.rawTransformations = [...transformations.flat(), ...$$props.rawTransformations || []];
    } catch (e) {
      console.warn(`Failed to preserve transformations: ${e.message}`);
    }
  }
  const func = ({ width: width2 }) => {
    const options = {
      ...imageProps,
      ...cldOptions,
      // Without, get a "never" type error on options.width
      width: imageProps.width
    };
    options.width = typeof options.width === "string" ? parseInt(options.width) : options.width;
    options.height = typeof options.height === "string" ? parseInt(options.height) : options.height;
    if (typeof width2 === "number" && typeof options.width === "number" && width2 !== options.width) {
      options.widthResize = width2;
    }
    return getCldImageUrl(options, config);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({
    getTransformations,
    transformationPlugins,
    Image: image_default,
    getCldImageUrl,
    CLD_OPTIONS,
    cldOptions,
    imageProps,
    height,
    width,
    src,
    alt,
    config
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("imageProps" in $$props)
      $$invalidate(0, imageProps = $$new_props.imageProps);
    if ("height" in $$props)
      $$invalidate(3, height = $$new_props.height);
    if ("width" in $$props)
      $$invalidate(4, width = $$new_props.width);
    if ("src" in $$props)
      $$invalidate(5, src = $$new_props.src);
    if ("alt" in $$props)
      $$invalidate(6, alt = $$new_props.alt);
    if ("config" in $$props)
      $$invalidate(2, config = $$new_props.config);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, { alt, src, width, height, config } = $$props, alt, ($$invalidate(5, src), $$invalidate(9, $$props)), ($$invalidate(4, width), $$invalidate(9, $$props)), ($$invalidate(3, height), $$invalidate(9, $$props)), ($$invalidate(2, config), $$invalidate(9, $$props)));
    if ($$self.$$.dirty & /*alt, src, width, height*/
    120) {
      $:
        $$invalidate(0, imageProps = {
          alt,
          src,
          width: typeof width === "string" ? parseInt(width) : width,
          height: typeof height === "string" ? parseInt(height) : height
        });
    }
    $:
      if (imageProps) {
        Object.keys($$props).filter((key) => !CLD_OPTIONS.includes(key)).forEach((key) => {
          $$invalidate(0, imageProps[key] = $$props[key], imageProps);
        });
      }
  };
  $$props = exclude_internal_props($$props);
  return [imageProps, cldOptions, config, height, width, src, alt, func];
}
var CldImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CldImage",
      options,
      id: create_fragment2.name
    });
  }
};
var CldImage_default = CldImage;

// node_modules/svelte-cloudinary/dist/constants/sizes.js
var OG_IMAGE_WIDTH = 2400;
var OG_IMAGE_WIDTH_RESIZE = 1200;
var OG_IMAGE_HEIGHT = 1254;

// node_modules/svelte-cloudinary/dist/components/CldOgImage.svelte
var file2 = "node_modules/svelte-cloudinary/dist/components/CldOgImage.svelte";
function create_if_block_1(ctx) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:image:alt");
      attr_dev(
        meta,
        "content",
        /*alt*/
        ctx[2]
      );
      add_location(meta, file2, 36, 2, 1337);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(36:1) {#if alt}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "twitter:title");
      attr_dev(meta, "content", meta_content_value = /*twitterTitle*/
      ctx[4] || " ");
      add_location(meta, file2, 43, 2, 1623);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(43:1) {#if !excludeTags.includes('twitter:title')}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let meta0;
  let meta1;
  let meta2;
  let meta2_content_value;
  let meta3;
  let meta3_content_value;
  let if_block0_anchor;
  let show_if = !/*excludeTags*/
  ctx[3].includes("twitter:title");
  let meta4;
  let meta5;
  let if_block0 = (
    /*alt*/
    ctx[2] && create_if_block_1(ctx)
  );
  let if_block1 = show_if && create_if_block2(ctx);
  const block = {
    c: function create() {
      meta0 = element("meta");
      meta1 = element("meta");
      meta2 = element("meta");
      meta3 = element("meta");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      meta4 = element("meta");
      meta5 = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-1ikysa4", document.head);
      meta0 = claim_element(head_nodes, "META", { property: true, content: true });
      meta1 = claim_element(head_nodes, "META", { property: true, content: true });
      meta2 = claim_element(head_nodes, "META", { property: true, content: true });
      meta3 = claim_element(head_nodes, "META", { property: true, content: true });
      if (if_block0)
        if_block0.l(head_nodes);
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.l(head_nodes);
      meta4 = claim_element(head_nodes, "META", { property: true, content: true });
      meta5 = claim_element(head_nodes, "META", { property: true, content: true });
      head_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta0, "property", "og:image");
      attr_dev(
        meta0,
        "content",
        /*ogImageUrl*/
        ctx[5]
      );
      add_location(meta0, file2, 30, 1, 1095);
      attr_dev(meta1, "property", "og:image:secure_url");
      attr_dev(
        meta1,
        "content",
        /*ogImageUrl*/
        ctx[5]
      );
      add_location(meta1, file2, 31, 1, 1146);
      attr_dev(meta2, "property", "og:image:width");
      attr_dev(meta2, "content", meta2_content_value = `${/*width*/
      ctx[0]}`);
      add_location(meta2, file2, 32, 1, 1208);
      attr_dev(meta3, "property", "og:image:height");
      attr_dev(meta3, "content", meta3_content_value = `${/*height*/
      ctx[1]}`);
      add_location(meta3, file2, 33, 1, 1265);
      attr_dev(meta4, "property", "twitter:card");
      attr_dev(meta4, "content", TWITTER_CARD);
      add_location(meta4, file2, 46, 1, 1696);
      attr_dev(meta5, "property", "twitter:image");
      attr_dev(
        meta5,
        "content",
        /*twitterImageUrl*/
        ctx[6]
      );
      add_location(meta5, file2, 47, 1, 1753);
    },
    m: function mount(target, anchor) {
      append_hydration_dev(document.head, meta0);
      append_hydration_dev(document.head, meta1);
      append_hydration_dev(document.head, meta2);
      append_hydration_dev(document.head, meta3);
      if (if_block0)
        if_block0.m(document.head, null);
      append_hydration_dev(document.head, if_block0_anchor);
      if (if_block1)
        if_block1.m(document.head, null);
      append_hydration_dev(document.head, meta4);
      append_hydration_dev(document.head, meta5);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*width*/
      1 && meta2_content_value !== (meta2_content_value = `${/*width*/
      ctx2[0]}`)) {
        attr_dev(meta2, "content", meta2_content_value);
      }
      if (dirty & /*height*/
      2 && meta3_content_value !== (meta3_content_value = `${/*height*/
      ctx2[1]}`)) {
        attr_dev(meta3, "content", meta3_content_value);
      }
      if (
        /*alt*/
        ctx2[2]
      )
        if_block0.p(ctx2, dirty);
      if (show_if)
        if_block1.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      detach_dev(meta0);
      detach_dev(meta1);
      detach_dev(meta2);
      detach_dev(meta3);
      if (if_block0)
        if_block0.d(detaching);
      detach_dev(if_block0_anchor);
      if (if_block1)
        if_block1.d(detaching);
      detach_dev(meta4);
      detach_dev(meta5);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var TWITTER_CARD = "summary_large_image";
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CldOgImage", slots, []);
  const options = {
    ...$$props,
    crop: $$props.crop || "fill",
    gravity: $$props.gravity || "center",
    height: $$props.height || OG_IMAGE_HEIGHT,
    src: $$props.src,
    width: $$props.width || OG_IMAGE_WIDTH,
    widthResize: $$props.width || OG_IMAGE_WIDTH_RESIZE
  };
  let width = typeof options.width === "string" ? parseInt(options.width) : options.width;
  let height = typeof options.height === "string" ? parseInt(options.height) : options.height;
  let { alt, excludeTags = [], twitterTitle } = $$props;
  if (typeof height === "number" && typeof width === "number") {
    height = OG_IMAGE_WIDTH_RESIZE / width * height;
  }
  width = OG_IMAGE_WIDTH_RESIZE;
  const ogImageUrl = getCldImageUrl({
    ...options,
    format: $$props.format || "jpg"
  });
  const twitterImageUrl = getCldImageUrl({
    ...options,
    format: $$props.format || "webp"
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({
    getCldImageUrl,
    OG_IMAGE_WIDTH,
    OG_IMAGE_WIDTH_RESIZE,
    OG_IMAGE_HEIGHT,
    TWITTER_CARD,
    options,
    width,
    height,
    alt,
    excludeTags,
    twitterTitle,
    ogImageUrl,
    twitterImageUrl
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("width" in $$props)
      $$invalidate(0, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(1, height = $$new_props.height);
    if ("alt" in $$props)
      $$invalidate(2, alt = $$new_props.alt);
    if ("excludeTags" in $$props)
      $$invalidate(3, excludeTags = $$new_props.excludeTags);
    if ("twitterTitle" in $$props)
      $$invalidate(4, twitterTitle = $$new_props.twitterTitle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [width, height, alt, excludeTags, twitterTitle, ogImageUrl, twitterImageUrl];
}
var CldOgImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CldOgImage",
      options,
      id: create_fragment3.name
    });
  }
};
var CldOgImage_default = CldOgImage;

// node_modules/svelte-cloudinary/dist/helpers/getCldOgImageUrl.js
function getCldOgImageUrl(options) {
  return getCldImageUrl({
    ...options,
    crop: options.crop || "fill",
    format: options.format || "jpg",
    gravity: options.gravity || "center",
    height: options.height || OG_IMAGE_HEIGHT,
    width: options.width || OG_IMAGE_WIDTH,
    widthResize: options.width || OG_IMAGE_WIDTH_RESIZE
  });
}
export {
  CldImage_default as CldImage,
  CldOgImage_default as CldOgImage,
  getCldImageUrl,
  getCldOgImageUrl
};
//# sourceMappingURL=svelte-cloudinary.js.map
